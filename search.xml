<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法笔记(3) —— 排序算法</title>
    <url>/2020/07/14/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(3)%20%E2%80%94%E2%80%94%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h1><p>冒泡排序的本质在于<strong>交换</strong>，即每次通过交换的方式把当前剩余元素的最大值移动到一端，而当前剩余元素减少为0时，排序结束。</p>
<p>对于一个拥有 n 个元素的数组进行冒泡排序，整个过程执行 n-1 趟，每一趟从左到右依次比较相邻的两个数，如果大的数在左边，则交换这两个数，当该趟结束时，该趟最大数被移动到当前剩余数的最右边。</p>
<p>具体代码实现如下：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++) &#123;    <span class="comment">//排序过程进行n-1趟</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-i; j++) &#123;    <span class="comment">//第i趟从a[0]到a[n-i-1]都与下一个数进行比较，每趟结束后最大的数在a[n-i]</span></span><br><span class="line">    	    <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>]) &#123;    <span class="comment">//如果左边的数更大，则交换a[j]和a[j+1]</span></span><br><span class="line">    		    <span class="keyword">int</span> temp = a[j];</span><br><span class="line">    		    a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">    		    a[j+<span class="number">1</span>] = temp;</span><br><span class="line">		    &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">50</span>], n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;    <span class="comment">//依次输入未排序的数组元素</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Bubble(a, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h1><h2 id="1、简单选择排序"><a href="#1、简单选择排序" class="headerlink" title="1、简单选择排序"></a>1、简单选择排序</h2><p>简单选择排序是众多选择排序中最常用的一种。简单排序的基本思想是：首先，选出最小的数，放在第一个位置；然后，选出第二小的数，放在第二个位置；以此类推，直到所有的数从小到大排序。</p>
<p>简单排序的具体实现为：对于数组 a[n]，令 i 从 0 枚举到 n-1，进行 n 趟操作，每趟从待排序部分 [i，n-1] 中选择最小的元素，令其与待排序部分的第一个元素 a[i] 进行交换，这样元素 a[i] 就会与当前有序区间 [0，i-1] 形成新的有序区间 [1，i]，在进行 n 趟操作后便可完成排序。</p>
<p>具体代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SimpleSelectSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mix, temp;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= n<span class="number">-1</span>; i++)&#123;    <span class="comment">//每次循环数组，找出最小的元素，放在前面</span></span><br><span class="line">        mix = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>; j &lt;= n<span class="number">-1</span>; j++) &#123;    <span class="comment">//找出未排序部分最小元素的下标</span></span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[mix]) &#123;</span><br><span class="line">                mix = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != mix) &#123;</span><br><span class="line">            temp = a[i];</span><br><span class="line">            a[i] = a[mix];</span><br><span class="line">            a[mix] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">50</span>], n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;    <span class="comment">//依次输入未排序的数组元素</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    SimpleSelectSort(a, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h1><h2 id="1、直接插入排序"><a href="#1、直接插入排序" class="headerlink" title="1、直接插入排序"></a>1、直接插入排序</h2><p>直接插入排序是众多插入排序方法中最直观的一种，直接插入排序是指，对于数组 a[n]，令 i 从 1 到 n-1 枚举，进行 n-1 趟操作，如果数组 a 的前 i-1 个元素 [0，i-1] 已经有序，而范围 [i，n-1] 还未有序，那么该趟从范围 [0，i-1] 中寻找某个位置 j，使得将 a[i] 插入位置 j 后范围 [0，i] 有序。</p>
<p>具体代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StraightInsertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;    <span class="comment">//从第二个元素开始枚举，与前面有序部分进行比较</span></span><br><span class="line">        <span class="keyword">int</span> j = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; a[j]) &#123;    <span class="comment">//当temp比其左边的数的值小时，从后向前枚举有序部分来确定插入位置</span></span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">50</span>], n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;    <span class="comment">//依次输入未排序的数组元素</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    StraightInsertSort(a, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、sort-排序"><a href="#四、sort-排序" class="headerlink" title="四、sort 排序"></a>四、sort 排序</h1><p>顾名思义，sort 函数就是用来排序的函数，它根据具体情况使用不同的排序方法，而且 sort 函数在实现的过程中规避了经典快速排序中可能会出现的会导致实际复杂度退化到 O($n^2$) 的极端情况，所以其效率比较高。</p>
<h2 id="1、如何使用-sort-排序"><a href="#1、如何使用-sort-排序" class="headerlink" title="1、如何使用 sort 排序"></a>1、如何使用 sort 排序</h2><p>sort 函数的使用必须加上头文件 “<strong>#include\<algorithm\></strong>” 和 “<strong>using namespace std;</strong>”，其使用方式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(首元素地址（必填），尾元素地址的下一个地址（必填），比较函数cmp（非必填）);</span><br></pre></td></tr></table></figure>
<p>对一个 int 型数组 a[4] = {3, 4, 9, 5} 进行排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(a, a + <span class="number">4</span>);    <span class="comment">//int型数组（double型也一样）默认从小到大进行排序，输出结果为3,4,5,9</span></span><br></pre></td></tr></table></figure>
<p>对一个 char 型数组 a[5] = {‘T’, ‘W’, ‘A’, ‘K’, ‘B’} 进行排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(a, a + <span class="number">5</span>);    <span class="comment">//char型数组默认按字典序从小到大进行排序，输出结果为A，B，K，T，W</span></span><br></pre></td></tr></table></figure>
<h2 id="2、如何实现比较函数-cmp"><a href="#2、如何实现比较函数-cmp" class="headerlink" title="2、如何实现比较函数 cmp"></a>2、如何实现比较函数 cmp</h2><h3 id="（1）基本数据类型数组的排序"><a href="#（1）基本数据类型数组的排序" class="headerlink" title="（1）基本数据类型数组的排序"></a>（1）基本数据类型数组的排序</h3><p>对一个 int 型数组 a[4] = {3, 4, 9, 5} 进行排序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;      <span class="comment">//从大到小排序，double型和char型同理</span></span><br><span class="line">    <span class="comment">//return a &lt; b;    //从小到大排序，double型和char型同理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    sort(a, a + <span class="number">4</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（2）结构体数组的排序"><a href="#（2）结构体数组的排序" class="headerlink" title="（2）结构体数组的排序"></a>（2）结构体数组的排序</h3><p>现定义了如下的结构体：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> y[<span class="number">10</span>];</span><br><span class="line">&#125;ssd[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>如果想先按 x 从大到小排序，但当 x 相等的情况下，按照 y 的大小从小到大来排序，则 cmp 函数的写法为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x != a.y) <span class="keyword">return</span> a.x &gt; b.x;            <span class="comment">//x不等时按x从大到小排序</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.y, b.y) &lt; <span class="number">0</span>;           <span class="comment">//x相等时按y从小到大排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考研</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>算法日记(2) —— 进制转换</title>
    <url>/2020/07/14/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0(2)%20%E2%80%94%E2%80%94%20%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>对于一个 P 进制的数，如果要转换成 Q 进制，需要分为两步：</p>
<ol>
<li><strong>将 P 进制的数 x 转换成十进制数 y</strong></li>
</ol>
<p>若 P 进制数 x 为 $a_1a_2···a_n$，则 x 可以通过以下公式转换为十进制数 y：</p>
<script type="math/tex; mode=display">
y = a_1*P^{n-1}+a_2*P^{n-2}+···+a_n</script><p>而这个公式可以很容易用循环来实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>, product = <span class="number">1</span>;    <span class="comment">//product在循环中会不断乘P，得到1、p、p^2、P^3···</span></span><br><span class="line"><span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">    y = y + (x % <span class="number">10</span>) * product;    <span class="comment">//x % 10是为了每次获取x的个位数</span></span><br><span class="line">    x = x / <span class="number">10</span>;    <span class="comment">//去掉x的个位</span></span><br><span class="line">    product = product * P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ol>
<li><strong>将十进制数 y 转换成 Q 进制数 z</strong></li>
</ol>
<p>采用“除基取余法”——所谓的“基”，是指将要转换成的进制 Q，因此除基取余的意思就是每次将待转换数除以 Q，然后将得到的余数作为低位存储，而商则继续除以 Q 并重复上面的操作，最后当商为 0 时，将所有位从高到低输出就可以得到 z。</p>
<p>由此可以得到实现的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> z[<span class="number">40</span>], num = <span class="number">0</span>;    <span class="comment">//数组z存放Q进制数y的每一位，num为位数</span></span><br><span class="line"><span class="keyword">do</span> &#123;    <span class="comment">//不使用while语句原因：如果十进制数y恰好等于0，使用while会直接跳出循环，导致结果出错</span></span><br><span class="line">    z[num++] = y % Q;</span><br><span class="line">    y = y / Q;</span><br><span class="line">&#125; <span class="keyword">while</span>(y != <span class="number">0</span>);    <span class="comment">//当商不为0时进行循环</span></span><br></pre></td></tr></table></figure>
<p>这样 z 数组从高位 z[num - 1] 到低位 z[0] 即为 Q 进制 z，进制转换完成。</p>
<div align='center'>【PAT B1022】D 进制的 A+B</div>


<p>题目描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入两个非负十进制整数A和B以及D（进制数），输出A+B的D（1&lt;D&lt;11）进制数。</span><br></pre></td></tr></table></figure>
<p>输入格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在一行中依次给出三个整数A、B和D（进制数）。</span><br></pre></td></tr></table></figure>
<p>输出格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A+B的D进制数。</span><br></pre></td></tr></table></figure>
<p>输入样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123 456 8</span><br></pre></td></tr></table></figure>
<p>输出样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1103</span><br></pre></td></tr></table></figure>
<p>参考代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;d);</span><br><span class="line">    <span class="keyword">int</span> sum = a + b;</span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">31</span>], num = <span class="number">0</span>;    <span class="comment">//ans存放D进制数的每一位</span></span><br><span class="line">    <span class="keyword">do</span> &#123;    <span class="comment">//进制转换</span></span><br><span class="line">        ans[num++] = sum % d;</span><br><span class="line">        sum /= d;</span><br><span class="line">    &#125; <span class="keyword">while</span>(sum != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = num - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;    <span class="comment">//从高位到低位进行输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考研</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
        <tag>算法习题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法日记(1) —— 日期差值</title>
    <url>/2020/07/13/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0(1)%20%E2%80%94%E2%80%94%20%E6%97%A5%E6%9C%9F%E5%B7%AE%E5%80%BC/</url>
    <content><![CDATA[<div align='center'>【codeup 1928】日期差值</div>

<p>题目描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有两个日期，求两个日期之间的天数，如果两个日期是连续的，则规定它们之间的天数为两天。</span><br></pre></td></tr></table></figure>
<p>输入格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有多组数据，每组数据有两行，分别表示两个日期，形式为YYYYMMDD。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>输出格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每组数据输出一行，及日期差值。</span><br></pre></td></tr></table></figure>
<p>样例输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20130101</span><br><span class="line">20130105</span><br></pre></td></tr></table></figure>
<p>样例输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<p>参考代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> month[<span class="number">13</span>][<span class="number">2</span>] = &#123;    <span class="comment">//平年和闰年的每个月天数</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">31</span>, <span class="number">31</span>&#125;, &#123;<span class="number">28</span>, <span class="number">29</span>&#125;, &#123;<span class="number">31</span>, <span class="number">31</span>&#125;, &#123;<span class="number">30</span>, <span class="number">30</span>&#125;, &#123;<span class="number">31</span>, <span class="number">31</span>&#125;, &#123;<span class="number">30</span>,<span class="number">30</span>&#125;,</span><br><span class="line">    &#123;<span class="number">31</span>, <span class="number">31</span>&#125;, &#123;<span class="number">31</span>, <span class="number">31</span>&#125;, &#123;<span class="number">30</span>, <span class="number">30</span>&#125;, &#123;<span class="number">31</span>, <span class="number">31</span>&#125;, &#123;<span class="number">30</span>, <span class="number">30</span>&#125;, &#123;<span class="number">31</span>, <span class="number">31</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;   <span class="comment">//判断是否为闰年 </span></span><br><span class="line">	<span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> time1, y1, m1, d1;</span><br><span class="line">	<span class="keyword">int</span> time2, y2, m2, d2;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;time1, &amp;time2) != EOF) &#123;</span><br><span class="line">		<span class="keyword">if</span>(time1 &gt; time2) &#123;    <span class="comment">//第一个日期晚于第二个日期，则交换</span></span><br><span class="line">			<span class="keyword">int</span> temp = time1;</span><br><span class="line">			time1 = time2;</span><br><span class="line">			time2 = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		y1 = time1 / <span class="number">1000</span>, m1 = time1 % <span class="number">10000</span> / <span class="number">100</span>, d1 = time1 % <span class="number">100</span>;</span><br><span class="line">		y2 = time2 / <span class="number">1000</span>, m2 = time2 % <span class="number">10000</span> / <span class="number">100</span>, d2 = time2 % <span class="number">100</span>;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//第一个日期没有达到第二个日期时进入循环</span></span><br><span class="line">		<span class="keyword">while</span>(y1 &lt; y2 || m1 &lt; m2 || d1 &lt; d2) &#123;</span><br><span class="line">			d1++;    <span class="comment">//第一个日期天数加1</span></span><br><span class="line">			<span class="keyword">if</span>(d1 == month[m1][isLeap(y1)] + <span class="number">1</span>) &#123;    <span class="comment">//日期数满当月天数</span></span><br><span class="line">				m1++;    <span class="comment">//第一个日期月份变为下一个月份</span></span><br><span class="line">				d1 = <span class="number">1</span>;    <span class="comment">//重置第一个日期的日期数为1</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(m1 == <span class="number">13</span>) &#123;    <span class="comment">//月份数满12个月</span></span><br><span class="line">				y1++;    <span class="comment">//第一个日期年份变为下一年</span></span><br><span class="line">				m1 = <span class="number">1</span>;    <span class="comment">//重置第一个日期的月份数为1</span></span><br><span class="line">			&#125;</span><br><span class="line">			ans++;    <span class="comment">//累计天数</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考研</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C/C++</tag>
        <tag>算法习题</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记(2) —— 指针</title>
    <url>/2020/07/11/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(2)%20%E2%80%94%E2%80%94%20%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="一、指针基本概念"><a href="#一、指针基本概念" class="headerlink" title="一、指针基本概念"></a>一、指针基本概念</h1><h2 id="1、指针自身的类型"><a href="#1、指针自身的类型" class="headerlink" title="1、指针自身的类型"></a>1、指针自身的类型</h2><p>从语法的角度看，只要<strong>把指针声明语句里的指针变量名去掉</strong>，剩下的部分就是该指针的类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr;          <span class="comment">//指针的类型是int*</span></span><br><span class="line"><span class="keyword">int</span> **ptr;         <span class="comment">//指针的类型是int**</span></span><br><span class="line"><span class="keyword">int</span> *ptr[<span class="number">3</span>];       <span class="comment">//指针的类型是int*[3]</span></span><br><span class="line"><span class="keyword">int</span> (*ptr)[<span class="number">3</span>];     <span class="comment">//指针的类型是int(*)[3]</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="2、指针指向的类型"><a href="#2、指针指向的类型" class="headerlink" title="2、指针指向的类型"></a>2、指针指向的类型</h2><p>当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。从语法上看，只要<strong>把指针声明语句中的指针名字和名字左边的指针声明符*去掉</strong>，剩下的部分就是指针所指向的类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr;          <span class="comment">//指针所指向的类型是int</span></span><br><span class="line"><span class="keyword">int</span> **ptr;         <span class="comment">//指针所指向的的类型是int*</span></span><br><span class="line"><span class="keyword">int</span> *ptr[<span class="number">3</span>];       <span class="comment">//指针所指向的类型是int[3]</span></span><br><span class="line"><span class="keyword">int</span> (*ptr)[<span class="number">3</span>];     <span class="comment">//指针所指向的的类型是int()[3]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>*p[N]， (*P)[N]，及**p的区别：</p>
<ul>
<li><code>int  *p[N]</code> 表示定义一个指针数组，也就是说定义了N个不同指向 int 型的指针。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b, c, d;</span><br><span class="line"><span class="keyword">int</span> *p[] = &#123;&amp;a, &amp;b, &amp;c, &amp;d&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>int (*p)[N]</code> 表示定义一个数组指针，指向一个 int [N] 型数组的指针。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>] = a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"(*(p+1))[1] = a[1][1] = %d\n"</span>, (*(p+<span class="number">1</span>))[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>int **p</code> 表示定义一个指向指针的指针。</li>
</ul>
</blockquote>
<h2 id="3、指针的值（指针所指向的内存区或地址）"><a href="#3、指针的值（指针所指向的内存区或地址）" class="headerlink" title="3、指针的值（指针所指向的内存区或地址）"></a>3、指针的值（指针所指向的内存区或地址）</h2><p>指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为 <code>sizeof(指针所指向的类型)</code> 的一片内存区。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">233</span>;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    p = &amp;a;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" &amp;a = %d\n"</span>, &amp;a);                        <span class="comment">// &amp;a = 6487572</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  p = %d\n"</span>, p);                         <span class="comment">//  p = 6487572</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p+1 = %d\n"</span>, p+<span class="number">1</span>);                       <span class="comment">//p+1 = 6487576</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof *p = %d\n"</span>, <span class="keyword">sizeof</span>(*p));          <span class="comment">//sizeof *p = 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof int = %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));        <span class="comment">//sizeof int = 4</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二、运算符-amp-和"><a href="#二、运算符-amp-和" class="headerlink" title="二、运算符&amp;和*"></a>二、运算符&amp;和*</h1><p>&amp; 是<strong>取地址运算符</strong>，* 是<strong>间接运算符</strong>。<br>&amp;a 的运算结果是一个<strong>指针</strong>，该指针的值是声明 a 时开辟的地址，指针的类型是 a 的类型对应的指针类型，指针所指向的类型就是 a 的类型，指针所指向的地址就是 a 的地址。<br>*p 的运算结果是 p 所指向的东西，类型是 p 指向的类型，所占用的地址是 p 所指向的地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">int</span> *p;       <span class="comment">//p是一个指针，该指针的自身的类型为int *型，指向的类型为int型。</span></span><br><span class="line">    <span class="keyword">int</span> **ptr;    <span class="comment">//ptr是一个二级指针（指向指针的指针），该指针自身的类型为int **型，指向的类型为int *型。</span></span><br><span class="line">    </span><br><span class="line">    p = &amp;a;       <span class="comment">//&amp;a的结果是一个指针，该指针的类型是int *型，指向的类型是int型，指向的地址是a的地址；</span></span><br><span class="line">                  <span class="comment">//将&amp;a赋值给p，即将变量a所在内存地址存放到p中。</span></span><br><span class="line">    *p = <span class="number">24</span>;      <span class="comment">//*p用于取出p中存放的内存地址（变量a的地址）所对应的内容（变量a的值）；</span></span><br><span class="line">                  <span class="comment">//将24赋值给*p，即将24赋值给变量a。</span></span><br><span class="line">    ptr = &amp;p;     <span class="comment">//&amp;p的运算结果是一个指针，该指针的类型为int **型；</span></span><br><span class="line">                  <span class="comment">//将&amp;p赋值给ptr，就是将指针p自身所在内存地址存放在到ptr中。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  ptr = &amp;p :\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"     ptr = %d\n"</span>, ptr);                 <span class="comment">//  ptr = 6487560</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    *ptr = %d\n"</span>, *ptr);                <span class="comment">// *ptr = 6487572</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"   **ptr = %d\n"</span>, **ptr);               <span class="comment">//**ptr = 24</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"      &amp;p = %d\n"</span>, &amp;p);                  <span class="comment">//   &amp;p = 6487560</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"       p = %d\n"</span>, p);                   <span class="comment">//    p = 6487572</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"      *p = %d\n"</span>, *p);                  <span class="comment">//   *p = 24</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"      &amp;a = %d\n"</span>, &amp;a);                  <span class="comment">//   &amp;a = 6487572</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"       a = %d\n"</span>, a);                   <span class="comment">//    a = 24</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"      &amp;b = %d\n"</span>, &amp;b);                  <span class="comment">//   &amp;b = 6487568</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"       b = %d\n"</span>, b);                   <span class="comment">//    b = 21</span></span><br><span class="line">    </span><br><span class="line">    *ptr = &amp;b;    <span class="comment">//*ptr用于取出ptr中存放的内存地址（指针p自身所在的地址）所对应的内容（指针p）；</span></span><br><span class="line">                  <span class="comment">//*ptr是一个指针，&amp;b的结果也是一个指针，这两个指针的类型和所指向的类型是一样的；</span></span><br><span class="line">                  <span class="comment">//将&amp;b赋值给*ptr，就是将变量b的地址存放到指针p中。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" *ptr = &amp;b :\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"     ptr = %d\n"</span>, ptr);                 <span class="comment">//  ptr = 6487560</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    *ptr = %d\n"</span>, *ptr);                <span class="comment">// *ptr = 6487568</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"   **ptr = %d\n"</span>, **ptr);               <span class="comment">//**ptr = 21</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"      &amp;p = %d\n"</span>, &amp;p);                  <span class="comment">//   &amp;p = 6487560</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"       p = %d\n"</span>, p);                   <span class="comment">//    p = 6487568</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"      *p = %d\n"</span>, *p);                  <span class="comment">//   *p = 21</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"      &amp;a = %d\n"</span>, &amp;a);                  <span class="comment">//   &amp;a = 6487572</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"       a = %d\n"</span>, a);                   <span class="comment">//    a = 24</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"      &amp;b = %d\n"</span>, &amp;b);                  <span class="comment">//   &amp;b = 6487568</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"       b = %d\n"</span>, b);                   <span class="comment">//    b = 21</span></span><br><span class="line">    </span><br><span class="line">    **ptr = <span class="number">34</span>;   <span class="comment">//**ptr先取出ptr中存放的地址所对应的内容（指针p），再对取出的内容进行*运算操作，即*p；</span></span><br><span class="line">                  <span class="comment">//将34赋值给**ptr，就是将34赋值给*p，也就是将34赋值给变量b。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"**ptr = 34 :\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"     ptr = %d\n"</span>, ptr);                 <span class="comment">//  ptr = 6487560</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    *ptr = %d\n"</span>, *ptr);                <span class="comment">// *ptr = 6487568</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"   **ptr = %d\n"</span>, **ptr);               <span class="comment">//**ptr = 34</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"      &amp;p = %d\n"</span>, &amp;p);                  <span class="comment">//   &amp;p = 6487560</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"       p = %d\n"</span>, p);                   <span class="comment">//    p = 6487568</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"      *p = %d\n"</span>, *p);                  <span class="comment">//   *p = 34</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"      &amp;a = %d\n"</span>, &amp;a);                  <span class="comment">//   &amp;a = 6487572</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"       a = %d\n"</span>, a);                   <span class="comment">//    a = 24</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"      &amp;b = %d\n"</span>, &amp;b);                  <span class="comment">//   &amp;b = 6487568</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"       b = %d\n"</span>, b);                   <span class="comment">//    b = 34</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、数组与指针"><a href="#三、数组与指针" class="headerlink" title="三、数组与指针"></a>三、数组与指针</h1><blockquote>
<p>重点补充：</p>
<ol>
<li>指针的加减，以<strong>指针所指向的类型</strong>为单位进行偏移。</li>
<li>首地址：一段内存空间中的第一个<strong>存储单元</strong>的地址，其类型为该存储单元类型对应的指针类型。</li>
</ol>
</blockquote>
<h2 id="1、一维数组与指针"><a href="#1、一维数组与指针" class="headerlink" title="1、一维数组与指针"></a>1、一维数组与指针</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"   a = %d\n"</span>, a);        <span class="comment">//   a = 6487552     a表示数组的首地址，并指向存储单元a[0]，其自身类型为int*型；</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" a+1 = %d\n"</span>, a+<span class="number">1</span>);      <span class="comment">// a+1 = 6487556     a+1偏移与指针所指向的类型（int型）有关，为4字节。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  &amp;a = %d\n"</span>, &amp;a);       <span class="comment">//  &amp;a = 6487552     &amp;a是一个指针，指向整个数组，其自身类型为int(*)[5]型；</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;a+1 = %d\n"</span>, &amp;a+<span class="number">1</span>);     <span class="comment">//&amp;a+1 = 6487572     &amp;a+1偏移与指针所指向的类型（int[5]型）有关，为20字节；</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof int = %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));                  <span class="comment">//sizeof int = 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof int[5] = %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>[<span class="number">5</span>]));            <span class="comment">//sizeof int[5] = 20</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2、二维数组与指针"><a href="#2、二维数组与指针" class="headerlink" title="2、二维数组与指针"></a>2、二维数组与指针</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"    &amp;a = %d\n"</span>, &amp;a);      <span class="comment">//    &amp;a = 6487520  &amp;a为指向整个二维数组的指针，其自身类型为int(*)[3][4]型；</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  &amp;a+1 = %d\n"</span>, &amp;a+<span class="number">1</span>);    <span class="comment">//  &amp;a+1 = 6487568  &amp;a+1偏移与指针指向的类型（int[3][4]型）有关，为48字节。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"     a = %d\n"</span>, a);       <span class="comment">//     a = 6487520  a表示二维数组的首地址，指向一维数组a[0]，类型为int*[4]型；</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"   a+1 = %d\n"</span>, a+<span class="number">1</span>);     <span class="comment">//   a+1 = 6487536  a+1便宜与指针指向的类型（int[4]型）有关，为16字节。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  a[0] = %d\n"</span>, a[<span class="number">0</span>]);    <span class="comment">//  a[0] = 6487520  a[0]表示一维数组的首地址，指向元素a[0][0]，类型为int*型；</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0]+1 = %d\n"</span>, a[<span class="number">0</span>]+<span class="number">1</span>);  <span class="comment">//a[0]+1 = 6487524  a[0]+1偏移与指针指向的类型（int）有关，为4字节。</span></span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof int[3][4] = %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>[<span class="number">3</span>][<span class="number">4</span>]));      <span class="comment">//sizeof int[3][4] = 48</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof int[4] = %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>[<span class="number">4</span>]));            <span class="comment">//sizeof int[4] = 16</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof int = %d\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));                  <span class="comment">//sizeof int = 4</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于三维数组 int a[1][2][3]，有：</p>
<ol>
<li>定位到数组元素 a[x][y][z] ：<code>*(*(*(a+x)+y)+z)</code> </li>
<li>指针（数组名）与自身类型、指向类型以及单位偏移量的关系表</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">指针或数组名</th>
<th style="text-align:center">自身类型</th>
<th style="text-align:center">指向类型</th>
<th style="text-align:center">单位偏移量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;a</td>
<td style="text-align:center">int(*)[1][2][3]</td>
<td style="text-align:center">int[1][2][3]</td>
<td style="text-align:center">sizeof(int[1][2][3]) $ = 1×2×3×4 = 24$字节</td>
</tr>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">int(*)[2][3]</td>
<td style="text-align:center">int[2][3]</td>
<td style="text-align:center">sizeof(int[2][3]) $ = 2×3×4 = 24$字节</td>
</tr>
<tr>
<td style="text-align:center">a[0]</td>
<td style="text-align:center">int(*)[3]</td>
<td style="text-align:center">int[3]</td>
<td style="text-align:center">sizeof(int[3]) $ = 3×4 = 12$字节</td>
</tr>
<tr>
<td style="text-align:center">a[0][0]</td>
<td style="text-align:center">int*</td>
<td style="text-align:center">int</td>
<td style="text-align:center">sizeof(int) $= 4$字节</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>总结：</p>
<ol>
<li>一维数组的首地址是该一维数组的第一个数组元素的地址；二维数组的首地址是该二维数组的第一个一维数组的地址。</li>
<li>a 和 &amp;a 的结果都是数组的首地址，但他们的类型是不一样的：<strong>a—— 数据类型 *</strong>；<strong>&amp;a—— 数据类型 (*) [数组元素个数]</strong>。</li>
<li><strong>数组名仅仅是“相当于”指针</strong>，而并不是真的是指针，数组名仅仅只是一个常量（一个值为数组首元素地址的常量），所以不能进行加减运算，而常量更是无法取地址的，之所以有 &amp;a，是因为这里的 a 此时<strong>代表了整个数组</strong>。</li>
</ol>
</blockquote>
<h2 id="四、结构体与指针"><a href="#四、结构体与指针" class="headerlink" title="四、结构体与指针"></a>四、结构体与指针</h2><p>访问结构体内的元素有两种方法：“ <code>.</code> ”操作和“ <code>-&gt;</code> ”操作。现将 studentInfo 型定义为如下形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    studentInfo *next;</span><br><span class="line">&#125;stu, *p;</span><br></pre></td></tr></table></figure>
<p>此时结构体变量中定义了普通变量 <code>stu</code> 和指针变量 <code>p</code>。</p>
<p>于是访问 <code>stu</code> 中变量的写法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stu.id</span><br><span class="line">stu.name</span><br><span class="line">stu.next</span><br></pre></td></tr></table></figure>
<p>而访问指针变量 <code>p</code> 中元素的写法有两种，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*p).id      或     p -&gt; id</span><br><span class="line">(*p).name    或     p -&gt; name</span><br><span class="line">(*p).next    或     p -&gt; next</span><br></pre></td></tr></table></figure>
<h2 id="五、函数与指针"><a href="#五、函数与指针" class="headerlink" title="五、函数与指针"></a>五、函数与指针</h2><p>指针类型可以作为函数参数的类型，这时视为把变量的地址传入函数。如果在函数中对这个地址中的元素进行改变，原先的数据就会确实地被改变，这种传递方式被称为<strong>地址传递</strong>。</p>
<p>由于函数在接收参数的过程中是单向一次性的<strong>值传递</strong>，即将实参传输给对应的形参，这样相当于产生了一个副本，对这个副本的操作不会影响实参的值，<strong>只有在获取实参地址的情况下对形参进行操作，才能真正地修改实参</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_correct</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_error1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;         <span class="comment">//当swap函数被调用时，为形参x和y（int型）分配存储空间，</span></span><br><span class="line">    <span class="keyword">int</span> temp = x;                        <span class="comment">//并将实参的值传入，函数执行过程中，将形参x和y的值进行交换，</span></span><br><span class="line">    x = y;                               <span class="comment">//当函数执行结束之后，形参x和y所占用的存储空间就会被释放，</span></span><br><span class="line">    y = temp;                            <span class="comment">//这种传递的方式，并不会对实参的值产生影响，此即为值传递。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_error2</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;       <span class="comment">//main函数传给swap函数的地址其实是一个无符号整形的数，其本身和普通</span></span><br><span class="line">    <span class="keyword">int</span> *temp = x;                       <span class="comment">//变量一样只是值传递，函数对地址的修改无法改变main函数中的实参的值，</span></span><br><span class="line">    x = y;                               <span class="comment">//必须对传入的地址所指向的数据进行修改才能改变main函数中的实参的值。</span></span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">1</span>, d = <span class="number">2</span>, e = <span class="number">1</span>, f = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> *p1 = &amp;c, *p2 = &amp;d, *p3 = &amp;e, *p4 = &amp;f;</span><br><span class="line">    </span><br><span class="line">    swap_error1(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, a, b);                <span class="comment">//a = 1, b = 2</span></span><br><span class="line"></span><br><span class="line">    swap_error2(p1, p2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c = %d, d = %d\n"</span>, *p1, *p2);            <span class="comment">//c = 1, d = 2</span></span><br><span class="line"></span><br><span class="line">    swap_correct(p3, p4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"e = %d, f = %d\n"</span>, *p3, *p4);            <span class="comment">//e = 2, f = 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>考研</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记(1) —— 基本数据类型</title>
    <url>/2020/06/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0(1)%20%E2%80%94%E2%80%94%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th>取值范围</th>
<th>大致范围</th>
<th>占用大小</th>
<th>输入格式</th>
<th>输出格式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">int</td>
<td>$- 2^{31}$ ~ $ +(2^{31} - 1)$</td>
<td>$- 2 × 10^9$ ~ $+2 × 10^9$</td>
<td>4Byte</td>
<td>scanf(“%d”, &amp;d);</td>
<td>printf(“%d”, d);</td>
</tr>
<tr>
<td style="text-align:left">long long</td>
<td>$- 2^{63}$ ~ $ +(2^{63} - 1)$</td>
<td>$- 9 × 10^{18}$ ~ $+9 × 10^{18}$</td>
<td>8Byte</td>
<td>scanf(“%lld”, &amp;lld);</td>
<td>printf(“%lld”, lld);</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td>$- 2^{128}$ ~ $ +2^{128}$</td>
<td>实际精度6~7位</td>
<td>4Byte(符号1位，指数8位，尾数23位)</td>
<td>scanf(“%f”, &amp;f);</td>
<td>printf(“%f”, f);</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td>$- 2^{1024}$ ~ $ +2^{1024}$</td>
<td>实际精度15~16位</td>
<td>8Byte(符号1位，指数11位，尾数52位)</td>
<td>scanf(“%lf”, &amp;lf);</td>
<td><strong>printf(“%f”, f);</strong></td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td>$-128$ ~ $+127$</td>
<td>$-128$ ~ $+127$</td>
<td></td>
<td>scanf(“%c”, &amp;c);字符串：<strong>scanf(“%s”, str);</strong></td>
<td>printf(“%c”, c); 字符串：printf(“%s”, str);</td>
</tr>
<tr>
<td style="text-align:left">bool</td>
<td>0 or 1(false or true)</td>
<td>0 or 1(false or true)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<blockquote>
<ol>
<li><p>小写字母比大写字母的ASCII码值大<strong>32</strong>；</p>
</li>
<li><p>由于数组名称本身就代表了数组第一个元素的地址，所以scanf中，<strong>char字符串数组整个输入的情况下不需要加取地址运算符</strong>；</p>
</li>
<li><p>在scanf中，<strong>%c格式是可以读入空格和换行的</strong>，其他格式的输入是以空格和换行作为读入结束的标志；</p>
</li>
<li><p>常用输出格式：<strong>%0md</strong>（使不足m位的int型变量以m位进行右对齐输出，高位用0补齐）、<strong>%.mf</strong>（使浮点数保留m位小数输出，服从“四舍五入五成双”的规则）；</p>
</li>
<li><p>getchar和putchar分别用来输入和输出<strong>单个字符（包括换行符）</strong>，gets和puts分别用来输入和输出<strong>一行字符串</strong>；</p>
</li>
<li><p>gets识别换行符<strong>\n</strong>作为输入结束，因此scanf完一个整数后，如果要使用gets，需要先用getchar接收整数后的换换行符；</p>
</li>
<li><p>char字符串数组的末尾都有一个<strong>空字符\0</strong>，以<strong>表示存放的字符串的结尾</strong>，结束符\0的ASCII码为0，即空字符NULL，占用一个字符位，因此创建char字符串数组时字符数组的长度比实际存储的字符串长度至少多1；</p>
</li>
<li><p>空字符\0和空格不是一个东西，空格的ASCII码为32；</p>
</li>
<li><p>常用 string 函数（使用时要在程序开头加上 <code>string.h</code> 头文件）：</p>
<p>(1). <code>strlen(str)</code> : 该函数用于返回字符数组中第一个\0前的字符个数；</p>
<p>(2). <code>strcmp(str1, str2)</code> : 该函数用于返回两个字符串大小的比较结果，比较原则是按<strong>字典序</strong>。如果<code>str1 &gt; str2</code>，则返回一个正整数，如果<code>str1 = str2</code>，则返回0，如果<code>str1 &lt; str2</code>，则返回一个负整数；</p>
<p>(3). <code>strcpy(str1, str2)</code> : 该函数用于将字符数组 str2 复制给字符数组 str1 ，包括结束符\0；</p>
<p>(4). <code>strcat(str1, str2)</code> : 该函数用于将字符数组 str2 接到字符数组 str1 后面；</p>
<p>(5). <code>sscanf(str, &quot;%d&quot;, &amp;n)</code> : 该函数用于将字符数组 str 中的内容以 “%d” 的格式写到 n 中；</p>
<p>(6). <code>sprintf(str, &quot;%d&quot;, n)</code> : 该函数用于将 n 以 “%d” 的格式写到字符数组 str 中。</p>
</li>
<li><p>字符数组的初始化方法：</p>
<p>(1). <code>char str[15] = {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;W&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;, &#39;!&#39;};</code></p>
<p>(2). 通过直接赋值字符串来初始化（<strong>仅限初始化</strong>，程序其他位置不允许直接赋值整个字符串）：</p>
<p>​       <code>char str[15] = &quot;Hello World!&quot;;</code></p>
</li>
<li><p>常用 math 函数（使用时要在程序开头加上 <code>math.h</code> 头文件）：</p>
<p>(1). <code>fabs(double x)</code> : 该函数用于对 double 型变量取绝对值；</p>
<p>(2). <code>floor(double x)</code> : 该函数用于对 double 型变量的向下取整；</p>
<p>(3). <code>ceil(double x)</code> : 该函数用于对 double 型变量的向上取整；</p>
<p>(4). <code>pow(double r, double p)</code> : 该函数用于返回 $r^p$ ，要求 r 和 p 都是 double 型变量；</p>
<p>(5). <code>sqrt(double x)</code> : 该函数用于返回 double 型变量的算术平方根；</p>
<p>(6). <code>log(double x)</code> : 该函数用于返回 double 型变量的以自然对数为底的对数；</p>
<p>(7). <code>round(double x)</code> : 该函数用于将 double 型变量四舍五入，返回值也是 double 型，需进行取整。</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>考研</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法基础</tag>
        <tag>PAT</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派零基础学习（1）</title>
    <url>/2020/06/04/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一、树莓派开机前的准备工作"><a href="#一、树莓派开机前的准备工作" class="headerlink" title="一、树莓派开机前的准备工作"></a>一、树莓派开机前的准备工作</h2><h3 id="（1）硬件及软件准备"><a href="#（1）硬件及软件准备" class="headerlink" title="（1）硬件及软件准备"></a>（1）硬件及软件准备</h3><h4 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h4><p>树莓派4B、树莓派电源线或安卓数据线、SD卡（16G以上）、读卡器、电脑、可触摸屏幕、HDMI线、无线键鼠</p>
<h4 id="软件准备"><a href="#软件准备" class="headerlink" title="软件准备"></a>软件准备</h4><p>SD Formatter、Win32DiskImager、VNC Viewer、putty、Notepad++、Advanced IP Scanner、树莓派镜像Raspbian-buster-full</p>
<blockquote>
<p>百度云：<a href="https://pan.baidu.com/s/1XJzltHUag9VFpm_QSrOaQQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1XJzltHUag9VFpm_QSrOaQQ</a>   提取码：kxfj</p>
</blockquote>
<h3 id="（2）格式化SD卡"><a href="#（2）格式化SD卡" class="headerlink" title="（2）格式化SD卡"></a>（2）格式化SD卡</h3><p>首先需要将SD卡格式化，将SD卡插入读卡器并接入电脑，打开<code>SD Formatter</code>，检查一下SD卡路径是否正确，若不正确的话需要点击<strong>Refresh</strong>刷新路径；若正确的话就可以直接点击<strong>Format</strong>进行格式化，格式化完成后电脑会重新读取读卡器，我的电脑中会出现一个<code>boot</code>盘，如果<strong>系统出现需要对“U盘”进行格式化的弹窗请点击取消</strong>，否则就需要重头开始格式化SD卡了。</p>
<a id="more"></a>
<h3 id="（3）在SD卡中烧录树莓派镜像"><a href="#（3）在SD卡中烧录树莓派镜像" class="headerlink" title="（3）在SD卡中烧录树莓派镜像"></a>（3）在SD卡中烧录树莓派镜像</h3><p>格式化SD卡成功后，打开<code>Win32DiskImager</code>选择之前下载的树莓派官方镜像（扩展名<code>.img</code>），SD卡路径系统会自动填充，然后点击<strong>Write</strong>等待写入完成。烧录成功后，boot盘里就会出现一系列的文件。</p>
<h3 id="（4）配置SSH文件"><a href="#（4）配置SSH文件" class="headerlink" title="（4）配置SSH文件"></a>（4）配置SSH文件</h3><p>在<code>boot</code>盘中手动创建一个空白记事本<code>.txt</code>文件，命名为<code>ssh</code>，删掉<code>.txt</code>扩展名。</p>
<h3 id="（5）配置Wi-Fi文件"><a href="#（5）配置Wi-Fi文件" class="headerlink" title="（5）配置Wi-Fi文件"></a>（5）配置Wi-Fi文件</h3><p>用同样的方法新建一个空白文件<code>wpa_supplicant.conf</code>（注意要删掉扩展名<code>.txt</code>），并用Notepad++打开<code>wpa_supplicant.conf</code>,输入以下配置，可以用多个<code>network{}</code>来配置多个Wi-Fi：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">country&#x3D;GB</span><br><span class="line">ctrl_interface&#x3D;DIR&#x3D;&#x2F;var&#x2F;run&#x2F;wpa_supplicant GROUP&#x3D;netdev</span><br><span class="line">update_config&#x3D;1</span><br><span class="line">network&#x3D;&#123;</span><br><span class="line">	ssid&#x3D;&quot;输入WiFi的名字，不删除引号,不能有中文&quot;</span><br><span class="line">	psk&#x3D;&quot;输入WiFi密码，不删除引号&quot;</span><br><span class="line">	priority&#x3D;输入数字，数字越大优先级越高</span><br><span class="line">&#125;</span><br><span class="line">network&#x3D;&#123;</span><br><span class="line">	ssid&#x3D;&quot;输入WiFi的名字，不删除引号,不能有中文&quot;</span><br><span class="line">	psk&#x3D;&quot;输入WiFi密码，不删除引号&quot;</span><br><span class="line">	priority&#x3D;输入数字，数字越大优先级越高</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、树莓派开机启动"><a href="#二、树莓派开机启动" class="headerlink" title="二、树莓派开机启动"></a>二、树莓派开机启动</h2><p>弹出读卡器，拔出SD卡并插到树莓派的SD卡槽中，用HDMI线将显示屏与树莓派相连，最后用树莓派电源线或安卓数据线给树莓派通电。树莓派上的红灯常亮，表示通电；绿灯间歇性亮，表示读写SD卡。如果绿灯闪烁，屏幕上显示出树莓派的logo，说明操作系统正常。</p>
<h2 id="三、树莓派换源（清华大学开源软件镜像站）"><a href="#三、树莓派换源（清华大学开源软件镜像站）" class="headerlink" title="三、树莓派换源（清华大学开源软件镜像站）"></a>三、树莓派换源（清华大学开源软件镜像站）</h2><h3 id="将Raspbain包管理器apt-get换源"><a href="#将Raspbain包管理器apt-get换源" class="headerlink" title="将Raspbain包管理器apt-get换源"></a>将<code>Raspbain</code>包管理器<code>apt-get</code>换源</h3><p>在树莓派的命令行界面输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br></pre></td></tr></table></figure>
<p>使用键盘方向键控制，在第一行开头加一个<code>#</code>，把以下代码拷贝到最后一行之后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; stretch main contrib non-free rpi</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; stretch main contrib non-free rpi</span><br></pre></td></tr></table></figure>
<p>修改完毕后，先按键盘上的<code>ctrl</code>+<code>o</code>，再按回车保存，再按<code>ctrl</code>+<code>x</code>退出Nano编辑器回到命令行界面，之后输入以下命令更新到清华大学镜像源最新的软件列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<p>这个命令，会访问源列表里的每个网址，并读取软件列表，然后保存在树莓派本地。</p>
<blockquote>
<p>以上步骤实现了Raspbian的包管理器<code>apt-get</code>换源到清华大学软件镜像站，并更新了软件列表，今后在树莓派命令行中执行<code>sudo apt-get install</code>+<code>软件名</code>时便会自动从清华大学开源软件镜像站高速下载软件。</p>
</blockquote>
<h3 id="将Python第三方模块安装工具pip换源"><a href="#将Python第三方模块安装工具pip换源" class="headerlink" title="将Python第三方模块安装工具pip换源"></a>将<code>Python</code>第三方模块安装工具<code>pip</code>换源</h3><h4 id="方法一：通过命令行换源"><a href="#方法一：通过命令行换源" class="headerlink" title="方法一：通过命令行换源"></a>方法一：通过命令行换源</h4><blockquote>
<p>清华大学开源软件镜像站官方推荐方法，但该方法在树莓派上可能会失效。</p>
</blockquote>
<p>只需树莓派命令行中输入下面这一行命令，即可永久设置pip下载源为国内源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip config set global.index-url https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure>
<h4 id="方法二：通过配置脚本换源"><a href="#方法二：通过配置脚本换源" class="headerlink" title="方法二：通过配置脚本换源"></a>方法二：通过配置脚本换源</h4><p>在树莓派的命令行中<strong>依次输入</strong>运行以下三个命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir ~&#x2F;.pip</span><br><span class="line">cd .pip</span><br><span class="line">sudo nano pip.conf</span><br></pre></td></tr></table></figure>
<p>在打开的文件中输入以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">timeout &#x3D; 10</span><br><span class="line">index-url &#x3D;  http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br><span class="line">extra-index-url&#x3D; http:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;</span><br><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;</span><br><span class="line">    mirrors.aliyun.com</span><br><span class="line">    pypi.douban.com</span><br></pre></td></tr></table></figure>
<p>先按键盘上的<code>ctrl</code>+<code>o</code>，再按回车保存，再按<code>ctrl</code>+<code>x</code>退出Nano编辑器回到命令行界面。</p>
<h2 id="四、树莓派内部配置"><a href="#四、树莓派内部配置" class="headerlink" title="四、树莓派内部配置"></a>四、树莓派内部配置</h2><p>打开树莓派命令行界面输入命令，输入以下代码进入树莓派配置界面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure>
<p>利用<strong>方向键</strong>切换光标位置。</p>
<h3 id="第一行：Change-User-Password修改密码"><a href="#第一行：Change-User-Password修改密码" class="headerlink" title="第一行：Change User Password修改密码"></a>第一行：<code>Change User Password</code>修改密码</h3><p>按照里面的要求修改成自己的密码即可。默认用户名为<code>pi</code>，密码为<code>raspberry</code>。</p>
<p>这个密码会用于<strong>远程SSH登陆</strong>、<strong>VNC远程桌面</strong>及<strong>管理员root权限</strong>。</p>
<h3 id="第四行：Localisation-Options选择地区"><a href="#第四行：Localisation-Options选择地区" class="headerlink" title="第四行：Localisation Options选择地区"></a>第四行：<code>Localisation Options</code>选择地区</h3><blockquote>
<p>通过<code>Change Locale</code>选项来选择所在国家：</p>
<p>将光标移到这个列表的最下面，让光标指在zh_CN.UTF-8 UTF-8前面，先按空格，再按回车，回到之前的界面再按回车。</p>
<p>通过<code>Change Timezone</code>选项来选择所在时区：</p>
<p>选择<code>Asia</code>，再选择<code>Shanghai</code>，回车确定。</p>
<p>通过<code>Change Wi-fi Country</code>选项来选择Wi-Fi国家：</p>
<p>选择<code>CN China</code>，回车确定。</p>
</blockquote>
<h3 id="第五行：Interfacing-Options开启功能"><a href="#第五行：Interfacing-Options开启功能" class="headerlink" title="第五行：Interfacing Options开启功能"></a>第五行：<code>Interfacing Options</code>开启功能</h3><p>打开<code>Camera</code>、<code>SSH</code>、<code>VNC</code>、<code>Serial</code>、<code>Remote GPIO</code>功能。</p>
<blockquote>
<p>Camera：摄像头</p>
<p>SSH：SSH远程通信与登陆</p>
<p>VNC：VNC远程桌面登陆</p>
<p>Serial：串口控制</p>
<p>Remote GPIO：远程GPIO引脚控制</p>
</blockquote>
<h3 id="第七行：Advanced-Options高级设置"><a href="#第七行：Advanced-Options高级设置" class="headerlink" title="第七行：Advanced Options高级设置"></a>第七行：<code>Advanced Options</code>高级设置</h3><blockquote>
<p>选择<code>Expand Filesystem</code>，将根目录扩展到这个SD卡，充分利用SD卡的存储空间。</p>
<p>选择<code>Overscan</code>，在整个屏幕上显示。</p>
<p>选择<code>Audio</code>，选择<code>Force 3.5mm(&#39;headphone&#39; jack)</code>，树莓派的声音会从耳机孔输出。</p>
<p>选择<code>Resolution</code>，选择默认设置，自动根据显示屏调整分辨率。</p>
<p>选择<code>Pixel Doubling</code>，增加桌面显示画质，选择<code>Finish</code>，会跳出对话框问是否重新启动，可以直接回车确定重启，也可以等下次启动时候生效。</p>
</blockquote>
<h2 id="五、获取树莓派IP地址"><a href="#五、获取树莓派IP地址" class="headerlink" title="五、获取树莓派IP地址"></a>五、获取树莓派IP地址</h2><ol>
<li><p>如果树莓派连接到了显示屏上，可以直接鼠标指向右上角网络图标，IP地址会自动显示；</p>
</li>
<li><p>如果树莓派连接到了显示屏上，可以打开树莓派命令行窗口，输入<code>ifconfig</code>；</p>
</li>
<li>如果没有显示屏，用手机连到与树莓派同一个网络的Wi-Fi下，打开苹果手机APP<code>dataplicity</code>应用上扫描出树莓派的IP地址；</li>
<li>如果没有显示屏，用电脑连到与树莓派同一个网络的Wi-Fi或者有线网络下，在电脑上打开<code>Advanced IP Scanner</code>，扫描出树莓派的IP地址。</li>
</ol>
<h2 id="六、远程登录树莓派"><a href="#六、远程登录树莓派" class="headerlink" title="六、远程登录树莓派"></a>六、远程登录树莓派</h2><p>通过之前的方法获取了树莓派的IP地址后就可以开始远程登录树莓派了，远程登录树莓派适合在没有屏幕或者有屏幕但不方便操作的情况下使用。</p>
<h3 id="方法一：putty"><a href="#方法一：putty" class="headerlink" title="方法一：putty"></a>方法一：putty</h3><p><code>putty</code>是用来在电脑上远程输入树莓派root命令的，其功能和电脑的command窗口很像，但无法像VNC那样可以显示图形界面。</p>
<p>打开<code>putty</code>，输入树莓派IP地址，端口<code>Port</code>默认为22，点击<code>Open</code>后会弹出一个英文的安全提示窗口，点击“是Y”就会打开一个命令行窗口，然后在黑色框里输入你的ID，输入<code>pi</code>，点回车，然后输入统一的默认密码<code>raspberry</code>（如果在之前的树莓派内部配置中修改了密码的话，则输入修改后的密码，<strong>由于Linux系统不显示密码，所以看不到输入的内容</strong>），确认回车后，就可以开始输入命令行了。</p>
<h3 id="方法二：VNC-Viewer"><a href="#方法二：VNC-Viewer" class="headerlink" title="方法二：VNC Viewer"></a>方法二：VNC Viewer</h3><p>想要使用VNC来远程登录树莓派必须先开启树莓派内部配置中<code>Interfacing Options</code>的<code>VNC</code>功能，没有屏幕的话只能先通过<code>putty</code>远程登录树莓派，再进行树莓派内部配置。</p>
<p>确认<code>VNC</code>功能开启后，打开<code>VNC Viewer</code>，选择顶部菜单栏<code>File</code>中的<code>New connection</code>建立新的连接，输入树莓派的IP地址并自定义新连接的名字，确认回车后，在出现的画面中点击Continue，然后就会出现一个需要输入ID和密码的界面，输入之后就能远程登录树莓派了。</p>
<h2 id="七、中文字体及输入法的下载和安装"><a href="#七、中文字体及输入法的下载和安装" class="headerlink" title="七、中文字体及输入法的下载和安装"></a>七、中文字体及输入法的下载和安装</h2><p>打开树莓派命令行，输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fonts-wqy-zenhei</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这行命令里的<code>sudo</code>表示使用管理员root权限，<code>apt-get</code>表示使用apt-get包管理器来下载，<code>install</code>表示下载安装，<code>fonts-wqy-zenhei</code>表示软件名字，所有的<code>sudo apt-get install</code>+<code>软件名</code>都表示这样的意思。</p>
</blockquote>
<p>接下来，安装中文输入法fcitx及Google拼音输入法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install fcitx fcitx-googlepinyin fcitx-module-cloudpinyin fcitx-sunpinyin</span><br></pre></td></tr></table></figure>
<p>在跳出的对话框中输入<code>y</code>和回车<code>↩</code>，确定下载安装，需要90MB存储空间。</p>
<p>安装成功之后，会在下一次重启时生效。</p>
<p>此后可以使用<code>ctrl</code>+<code>空格</code>切换为中文输入法。</p>
<h2 id="八、升级所有安装的软件"><a href="#八、升级所有安装的软件" class="headerlink" title="八、升级所有安装的软件"></a>八、升级所有安装的软件</h2><p>运行下面这行命令，会把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新，执行这行命令可能需要很长时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们刚刚还运行了<code>sudo apt-get update</code>命令，现在运行<code>sudo apt-get upgrade</code>命令，有什么不同呢？</p>
<p>答：<code>update</code>仅仅是从下载源获取并更新可下载软件列表，相当于更新索引地图，而<code>upgrade</code>是更新软件本身，所以后者要花费多得多的时间。</p>
</blockquote>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>RaspberryPi</tag>
        <tag>硬件开发</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>HCIP-IoT Developer认证——物联网基础</title>
    <url>/2020/06/04/HCIP-IoT%20Developer%E8%AE%A4%E8%AF%81%E2%80%94%E2%80%94%E7%89%A9%E8%81%94%E7%BD%91%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="一、物联网概述"><a href="#一、物联网概述" class="headerlink" title="一、物联网概述"></a>一、物联网概述</h2><h3 id="物联网简介"><a href="#物联网简介" class="headerlink" title="物联网简介"></a>物联网简介</h3><p>物联网（Internet of Things）概念最早于<strong>1999年</strong>由美国MIT提出，早期的物联网是指依托RFID（Radio Frequency Identification）技术和设备，按约定的通信协议与互联网结合，使物品信息实现智能化识别和管理，实现物品信息互联、可交换和共享而形成的网络。</p>
<p>物联网是新一代信息技术的重要组成部分，也是“信息化”时代的重要发展阶段。物联网通过智能感知、识别技术与普适计算等通信感知技术，广泛应用于网络的融合中，也因此被称为继计算机、互联网之后世界信息产业发展的第三次浪潮。</p>
<p>通过二维码识读设备、射频识别（RFID）装置、红外感应装置、全球定位系统和激光扫描器等信息传感设备，按约定的协议，把<strong>任何物品与互联网相连接</strong>，进行信息交换和通信，以实现智能化识别、定位、跟踪、监控和管理的一种网络。                                                                                                  ——国际电信联盟（ITU）</p>
<p>物联网就是<strong>物物相连</strong>的互联网，这其中有两层意思：其一，物联网的核心和基础仍然是互联网，是在互联网的基础上的延伸和扩展的网络；其二，其用户端延伸和扩展到了任何物品与物品之间，进行信息交换和通信，也就是物物相息。                                                                                                                  ——百度百科</p>
<a id="more"></a>
<h3 id="主流物联网接入技术应用场景划分"><a href="#主流物联网接入技术应用场景划分" class="headerlink" title="主流物联网接入技术应用场景划分"></a>主流物联网接入技术应用场景划分</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">接入技术</th>
<th style="text-align:center">特点</th>
<th style="text-align:center">业务应用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4G/5G/LTE-V</td>
<td style="text-align:center">传输速率&gt;10Mbps，功耗较高</td>
<td style="text-align:center">车联网、视频监控、智能机器等</td>
</tr>
<tr>
<td style="text-align:center">eMTC/GPRS</td>
<td style="text-align:center">传输速率&lt;1Mbps，成本较低，功耗较低</td>
<td style="text-align:center">穿戴、车辆调度、电子广告、无线ATM等</td>
</tr>
<tr>
<td style="text-align:center">NB-IoT</td>
<td style="text-align:center">传输速率&lt;100Kbps，成本低，功耗低，覆盖广</td>
<td style="text-align:center">远程抄表、公共事业、农林渔牧、数据采集等</td>
</tr>
</tbody>
</table>
</div>
<h3 id="物联网层次架构"><a href="#物联网层次架构" class="headerlink" title="物联网层次架构"></a>物联网层次架构</h3><p>物联网的层次架构可以分为<strong>端</strong>（信息收集和信号处理）、<strong>边</strong>（IoT 边缘）、<strong>管</strong>（接入和传输网络）、<strong>云</strong>（解决数据如何存储、检索、使用、业务规划、安全、维护、费用等）、<strong>行业应用</strong>（数据呈现及客户交互）；也可分为感知层、网络层、平台层和应用层。</p>
<h3 id="物联网产业发展面临的主要挑战"><a href="#物联网产业发展面临的主要挑战" class="headerlink" title="物联网产业发展面临的主要挑战"></a>物联网产业发展面临的主要挑战</h3><ol>
<li>新业务上线周期长（应用碎片化，开发周期长，产品上市慢）</li>
<li>终端/传感器厂家众多导致集成困难</li>
<li>网络联接复杂</li>
</ol>
<h2 id="二、华为IoT联接管理平台——Oceanconnect"><a href="#二、华为IoT联接管理平台——Oceanconnect" class="headerlink" title="二、华为IoT联接管理平台——Oceanconnect"></a>二、华为IoT联接管理平台——Oceanconnect</h2><h3 id="华为IoT联接平台概述"><a href="#华为IoT联接平台概述" class="headerlink" title="华为IoT联接平台概述"></a>华为IoT联接平台概述</h3><p>发展物联网业务需要一个终端<strong>接入解耦</strong>、<strong>平台与应用分离（能力开放）</strong>、<strong>安全可靠</strong>的平台作为支撑；华为IoT联接管理平台Oceanconnect具有终端接入、安全验证、业务编排、数据管理、多协议通信的功能，能实现连接管理和能力开放，并完成与运营商管道和平台对接。</p>
<h3 id="Oceanconnect产品架构"><a href="#Oceanconnect产品架构" class="headerlink" title="Oceanconnect产品架构"></a>Oceanconnect产品架构</h3><ol>
<li>华为“IoT全栈”解决方案（1+2+1）：一个统一的物联网平台、两种网络接入方式、一个统一的操作系统。</li>
<li>典型组网：应用使能平台服务（AEP）、通用应用使能服务（CAES）、车联网服务（Vehicle）、数据分析服务（DAS）、设备管理服务（DMP）、云平台服务（CSP）、设备接入和能力开放等。</li>
<li>功能架构：<strong>终端层</strong>（提供标准IoT Agent，能够快速适配OS和各类厂商的智能终端）、<strong>接入层</strong>（包括接入网络和接入协议，通过IoT Agent适配不同厂商的传感器，以便于接入海量设备）、<strong>设备连接层</strong>（主要提供统一的接入能力、资产和设备管理、SIM卡连接管理等功能）、<strong>设备管理层及业务使能层</strong>（提供API开放网关、数据管理、规则引擎等功能）、<strong>应用层</strong>（支持多种Open API形式，支持预集成多个行业应用，主要包括智慧园区、车联网、智慧城市和第三方应用）。</li>
</ol>
<h3 id="Oceanconnect业务与功能"><a href="#Oceanconnect业务与功能" class="headerlink" title="Oceanconnect业务与功能"></a>Oceanconnect业务与功能</h3><ol>
<li><p><strong>设备管理</strong></p>
</li>
<li><p><strong>设备（网关）通信管理</strong></p>
<p>设备登录：即网关的接入登录。</p>
<p>数据通信：即网关到Oceanconnect间的数据通信管理（基于MQTT连接），Oceanconnect和终端的数据通信路径的建立和维护，实现连接状态变化的感知，IoT平台与网关间数据的交换。</p>
<p>设备订阅：即用户数据到网关的连接管理，网关通过到Oceanconnect的订阅，实现网关对用户（SP用户/最终用户）数据的监控，用户对终端下发的命令实时通过IoT平台转发给网关。</p>
<p>用户订阅：即网关数据到用户的连接管理，用户通过到IoT平台的订阅，实现用户对网关的监控，网关实时上报的数据通过Oceanconnect转发给用户。</p>
<p>用户订阅</p>
</li>
<li><p><strong>设备接入鉴权</strong></p>
<p>创建传感器鉴权：当有新的传感器接入时，网关携带平台分配的合法会话信息创建传感器，IoT平台对其他合法性进行检查，检查通过后，将新的传感器加入到网关下面，以便进行传感器的数据上报功能。</p>
<p>设备接入鉴权：网关启动后，设备携带Device ID和密码接入Oceanconnect，Oceanconnect对其鉴权确认合法性，如果合法则返回200 OK，携带为其分配的合法性会话信息，设备完成登录。</p>
<p>上报数据鉴权：当传感器通过网关上报数据时，网关携带IoT平台分配的合法信息上报传感器数据，IoT平台对其合法性进行检查，检查通过后，将传感器数据记录在IoT平台并上报给最终用户。</p>
</li>
<li><p><strong>规则引擎</strong>：使用对象是终端用户，可以定位处理各种事件，利用规则引擎可以完成异常事件的及时通知和快速处理，帮助用户维护和监控设备，保证系统业务的及时恢复。</p>
</li>
<li><p><strong>数据转发</strong></p>
</li>
<li><p><strong>数据转发</strong></p>
</li>
<li><p><strong>API开放管理</strong></p>
</li>
<li><p><strong>多租户管理</strong></p>
</li>
<li><p><strong>Portal管理</strong></p>
</li>
</ol>
<h3 id="Oceanconnect产品特点"><a href="#Oceanconnect产品特点" class="headerlink" title="Oceanconnect产品特点"></a>Oceanconnect产品特点</h3><ol>
<li><strong>接入无关</strong>：任意方式连接、任意设备连接；</li>
<li><strong>可靠性</strong>：系统可靠性、网络可靠性、业务可靠性、模块可靠性；</li>
<li><strong>安全性</strong>：业务安全、平台安全、接入安全、传感器安全；</li>
<li><strong>能力开放</strong>：平台向上API开放、平台向下Agent开放、预集成高价值行业、终端管理平台开放；</li>
<li><strong>弹性伸缩</strong></li>
</ol>
<h3 id="Oceanconnect关键特性"><a href="#Oceanconnect关键特性" class="headerlink" title="Oceanconnect关键特性"></a>Oceanconnect关键特性</h3><ol>
<li><p><strong>设备接入：提供支持设备接入平台的能力，支持多种协议接入及多宗接入方式</strong></p>
<p>IoT平台通过引入CIG（Cloud Inter-Networking Gateway，云端接入网关），解决不同类型、不同通信协议的设备接入IoT平台的问题。CIG通过将各种不同的南向协议发送的消息转换为平台可以识别的Json格式。除CIG之外，直连设备还可以通过集成Agent Lite（瘦网关）快速接入平台，实现数据上报和命令下发等功能。</p>
<p>目前IoT平台支持使用以下原生协议接入：</p>
<ul>
<li><p><strong>LWM2M over CoAP</strong>原生协议接入：主要面向基于蜂窝的窄带物联网（NB-IoT）场景下物联网应用，具有覆盖广、连接多、速率低、成本低、功耗低等特点。</p>
</li>
<li><p><strong>MQTT/MQTTS</strong>原生协议接入：主要应用于计算能力有限，且工作在低带宽、不可靠的网络的远程传感器和控制设备。</p>
</li>
</ul>
</li>
<li><p><strong>应用集成：提供行业应用接入平台的能力，通过API实现平台能力开放</strong></p>
<p><strong>应用注册鉴权</strong>：SP用户基于华为的IoT平台开发物联网应用，首先需要再IoT平台的管理门户上，根据自身行业应用的特征申请平台资源，获取注册鉴权信息（包括应用ID、应用密钥），确保每个SP用户合法的接入到平台，合法的享用平台资源，高效地利用平台提供的服务套件进行应用开发。</p>
<p><strong>订阅通知</strong>：行业应用通过API接口向IoT平台进行订阅，告知IoT平台行业应用需要收到收到的通知类型，比如绑定设备，设备数据变化，升级状态变化等。当平台中设备的相关信息有更新时，平台会通过<strong>HTTP/HTTPS</strong>协议向应用侧推送消息。</p>
<p>在推送场景下，IoT平台是客户端，应用服务器是服务端，IoT平台调用应用服务器的接口，并向服务端，IoT平台调用应用服务器的接口，并向应用服务器推送消息。此时，如果订阅的回调地址为HTTPS地址，则需要再物联网上传CA证书，CA证书由应用服务器侧提供。</p>
<p><strong>北向Restful API</strong>：当前IoT平台对外提供了应用安全接入、设备管理、批量处理、订阅管理、命令下发、数据采集、设备组管理、设备升级等开放API。</p>
</li>
<li><p><strong>设备管理：提供平台对设备和设备数据的操作管理能力</strong></p>
<p><strong>设备发放</strong>，即设备注册，指SP用户通过管理门户或通过调用注册设备API在IoT平台中注册设备信息，平台中存在设备信息后，再接入真实的实体设备，这样平台与终端实体设备可以实现连接和通信。</p>
<p><strong>设备接入鉴权</strong>，是指IoT平台对接入平台的设备进行鉴权认证，鉴权内容包括设备接入信息的完整性和安全性、设备与平台消息传输完整性和安全性。</p>
<p><strong>设备访问授权</strong>，IoT平台支持应用间的授权操作，包括同一个SP用户下的不同应用之间授权、不同SP用户下的不同应用之间授权。被授权的应用可以通过管理门户查看和操作授权应用下的所有设备。</p>
<p><strong>设备数据采集</strong>，IoT平台提供设备数据采集功能，支持对设备数据的订阅，应用向IoT平台进行设备数据订阅，当设备上报数据时，平台会向应用推送消息；支持查看设备上报的历史数据，可通过管理门户或者调用API查看设备的历史数据。</p>
<p><strong>设备影子</strong>，IoT平台支持创建设备的“影子”，用于存储设备上报的最新数据（report区）和应用对设备属性的最新配置数据（desired区）。</p>
<ul>
<li><p>report区</p>
<p>当IoT平台获取到设备真实数据时，会将真实数据同步到设备影子的report区；当设备不在线时，可以通过设备影子获取最新数据。</p>
</li>
<li><p>desired区</p>
<p>设备在线时，设备影子的desired区数据会即时同步到设备；设备不在线时，设备影子的desired区数据会在设备上线后同步到设备。</p>
</li>
</ul>
<blockquote>
<p>仅LWM2M协议设备支持设备影子功能。</p>
<p>仅支持修改LWM2M协议定义的属性信息，用户自定义的设备属性信息暂不支持修改。</p>
</blockquote>
<p><strong>命令下发</strong>，IoT平台提供两种命令下发机制：</p>
<ul>
<li><strong>立即下发</strong>：IoT平台立即发送收到的命令，如果设备不在线则下发失败；</li>
<li><strong>缓存下发</strong>：IoT平台收到命令后放入队列，在设备上线的时候，平台依次下发命令队列中的命令。</li>
</ul>
<p><strong>设备远程诊断</strong>，IoT平台支持用户对接入平台的设备（当前仅支持NB-IoT设备）进行远程维护操作：</p>
<ul>
<li><strong>日志收集</strong>：系统通过日志管理服务对用户操作和系统运行痕迹进行记录，有助于迅速定位问题及快速恢复故障，使运维工程师更精确、更高效地进行设备日常维护。</li>
<li><strong>远程重启</strong>：当需要对设备或者模组进行重启操作时，可通过管理门户，选择需要重启的设备或者模组进行重新操作。</li>
</ul>
<p><strong>设备升级策略管理</strong>，IoT平台支持对软件和固件升级的相关策略管理：</p>
<ul>
<li><strong>升级时间策略管理</strong>：用户在进行升级操作时，可以灵活的设置软件和固件升级的时间，提前根据设备和业务的间隙期选择升级时间；</li>
<li><strong>升级并发数控制</strong>：IoT平台支持根据设备无线信号覆盖情况对升级并发数进行控制，IoT平台将设备无线覆盖等级分为3个等级（0、1和2），并预置每个等级的无线覆盖强度（RSRP）门限值和信噪比（SINR）门限值，根据无线信号的覆盖强度，进行设备升级。</li>
</ul>
<p><strong>设备固件升级及设备软件升级</strong>：</p>
<ul>
<li>设备固件升级（FOTA）是通过OTA（Over the Air）的方式对设备的模组进行升级，基于LWM2M标准协议实现。</li>
<li>设备软件升级（SOTA）是通过OTA的方式对终端设备的MCU进行升级，基于华为定义的PCP升级协议实现。</li>
</ul>
</li>
<li><p><strong>NB-IoT云网协同：通过与核心网网元对接，实现对NB-IoT设备的优化控制</strong></p>
<p><strong>DTLS+</strong>：DTLS+（Datagram Transport Layer Security，数据报传输层安全性协议）是华为IoT平台采用的数据报传输层安全协议，相比传统DTLS协议，在会话协商等方面做了优化，减少了NB-IoT设备与IoT平台通信过程中的握手次数，从而延长终端电池的使用寿命。</p>
<p><strong>NB-IoT设备省电模式</strong>：</p>
<ul>
<li><p><strong>PSM</strong>：最省电的模式，设备非业务期间深度休眠，不接收下行数据，只有设备主动发送上行数据时可接收IoT平台缓存的下行数据，适合对下行数据无时延要求的业务；</p>
</li>
<li><p><strong>DRX</strong>：不连续接收模式，最耗电的模式，在每个DRX周期，设备都会检测一次是否有下行业务到达，适用于对时延有高要求的业务，设备一般采取供电的方式；</p>
</li>
<li><p><strong>eDRX</strong>：扩展不连续接收模式，设备兼顾低功耗和对时延有一定要求的业务，在每个eDRX周期内，只有在设置的寻呼时间窗口内，终端可接收下行数据，其余时间终端处于休眠状态，不接收下行数据。</p>
</li>
</ul>
<p><strong>NB-IoT上行拥塞控制</strong>：当有大量NB-IoT设备同时上线时，容易造成网络拥塞。IoT平台通过NB-IoT上行离散控制功能，统一为设备分配上线时间，让设备可以错峰接入，提高设备上线率。</p>
<p><strong>NB-IoT下行拥塞控制</strong>：NB-IoT基站的空口寻呼能力资源有限，当需要为重要业务预留资源或者网络即将发生拥塞时，IoT平台针对立即下发及缓存下发两种请求，实时下行拥塞控制，减少从IoT平台或应用下发到网络侧的寻呼数，从而实现网络拥塞控制目标。</p>
<ul>
<li>针对立即下发的下行消息，如果基站小区寻呼并发数超过小区阈值时，则直接拒绝该请求，减少下发的下行消息数量。</li>
<li>针对缓存下发的下行消息，如果基站小区寻呼并发数超过小区阈值时，则排队等待，延迟下行消息的下发时间。</li>
</ul>
</li>
<li><p><strong>第三方系统集成：提供与第三方系统的对接能力</strong></p>
<p><strong>短信系统对接和邮件系统对接</strong>：IoT平台支持与现网的短信系统（或邮件系统）通过SMPP协议（邮件系统为SMTP协议）进行对接，以便用户在IoT平台上进行相关业务操作（如SP账号的注册、密码找回等）时，可以将信息通过短信（或邮件）的形式发送给用户。</p>
</li>
<li><p><strong>运营运维：通过管理门户提供对平台的运营操作管理</strong></p>
<p><strong>审计日志</strong>：用户在使用IoT平台的过程中，系统会以日志形式收集并记录用户及平台的操作结果，当某项功能发生异常时，用户可以根据日志的记录信息定位并处理故障问题。</p>
<ul>
<li><strong>操作日志</strong>：记录用户和系统所做的操作和结果，如导出配置、删除配置等，用于跟踪和审计。</li>
<li><strong>安全日志</strong>：记录涉及系统安全操作信息，如创建用户登录、用户确认隐私声明等，用户了解系统安全操作相关信息，及时发现潜在的安全隐患并进行处理。</li>
<li><strong>个人数据查询日志</strong>：记录用户对账户进行的操作和结果，如查询用户详情、查询登录历史、查询全局用户列表等，用于跟踪和安全审计。</li>
<li><strong>业务日志</strong>：记录涉及平台业务的操作及结果，例如创建设备、南向设备登录等，用于跟踪南北向业务相关信息，及时发现问题并处理。</li>
</ul>
</li>
</ol>
<h2 id="三、华为Oceanconnect端到端开发"><a href="#三、华为Oceanconnect端到端开发" class="headerlink" title="三、华为Oceanconnect端到端开发"></a>三、华为Oceanconnect端到端开发</h2><blockquote>
<p>本章内容包含从NB终端设备到应用服务完整的开发流程，包括IoT平台北向接口调用机制和方法，数据上报和命令下发的流程和规范，设备描述文件和编码插件的开发流程，以及NB终端设备与平台的联通机制。IoT云平台作为一个联接管理平台，不但连通了终端设备和北向应用服务的数据通道，而且规范了数据交互流程和格式，保证了数据服务的完整性和可扩展性。</p>
</blockquote>
<h3 id="整体方案介绍"><a href="#整体方案介绍" class="headerlink" title="整体方案介绍"></a>整体方案介绍</h3><p>上行消息：解析CoAP报文得到应用层数据→调用设备厂商profile和插件解码→消息送达应用平台</p>
<p>下行消息：下发消息→调用设备厂商提供的profile和编解码插件编码→组装CoAP消息发送到设备</p>
<h3 id="北向业务服务开发"><a href="#北向业务服务开发" class="headerlink" title="北向业务服务开发"></a>北向业务服务开发</h3><ol>
<li>北向接入机制：REST（Representational State Transfer，简称REST）描述了一个架构样式的网络系统，即指的是一组架构约束条件和原则，满足这些约束条件和原则的应用程序或设计就是RESTful。</li>
<li>北向API：应用安全接入、设备管理、批量处理、订阅管理、消息推送、命令下发、数据采集、设备组管理、设备升级</li>
</ol>
<h3 id="设备Profile描述文件"><a href="#设备Profile描述文件" class="headerlink" title="设备Profile描述文件"></a>设备Profile描述文件</h3><p>设备的Profile文件是用来<strong>描述设备类型和设备服务能力</strong>的文件，它定义了设备具备的服务能力，每个服务具备的属性、命令以及命令的参数。</p>
<ol>
<li>设备能力（Device Capability）描述一款设备的能力特征，包括设备类型、厂商、型号、协议类型以及提供的服务类型。</li>
<li>服务（Service）描述设备具备的服务能力，每个服务具备的属性、命令以及命令的参数。</li>
</ol>
<h3 id="编解码插件开发"><a href="#编解码插件开发" class="headerlink" title="编解码插件开发"></a>编解码插件开发</h3><p>通过图形化的方式实现设备的二进制码流到IoT平台的Json格式消息的转化，同时将平台下发的控制命令编解成设备的二进制码流格式。</p>
<ol>
<li><p><strong>上行消息处理流程</strong></p>
<ul>
<li>南向设备（UE）通过采集数据，并将数据按自定义规则进行编码；</li>
<li>南向设备通过串口，以及AT命令的形式，发送已经编码的数据到NB-IoT模组；</li>
<li>NB-IoT芯片/模组，接收到AT命令后，自动封装为CoAP协议的消息，并发送给事先配置好的华为物联网平台；</li>
<li>华为物联网平台收到数据后，自动解析CoAP协议包，根据设备Profile文件，找到匹配的编解码插件，对Payload进行解析，解析为与设备Profile中描述的Service匹配的Json数据，并保存于平台之上；</li>
<li>应用服务器（APP Server）通过北向数据查询接口（RESTful）获取平台上的数据；同时也可以提前调用订阅接口，对数据变化进行订阅，则之后所有的数据变化，平台都会通过POST消息，发送到指定的服务器。</li>
</ul>
</li>
<li><p><strong>下行消息处理流程</strong></p>
<ul>
<li>IoT平台应用服务器（APP Server）创建信令（命令的相关项需要和设备Profile中的描述一致），发送到IoT平台；</li>
<li>收到之后，会先判断设备是否在线，如果在线，则立即下发信令，如果平台判断设备离线，则信令将缓存于平台的数据库中；</li>
<li>南向设备（UE）在某个时刻上报数据，平台收到数据后，将检索对应设备在数据库中是否存在有效未下发的信令（即缓存信令），如有，则下发该信令；</li>
<li>信令通过编解码插件进行编码（Json到二进制码流），并被发送到设备端（UE）；</li>
<li>南向设备（UE）收到信令，执行完毕，返回信令执行结果，IoT平台收到上述执行结果，通过编解码插件的解析，获取信令执行的结果，修改对应的信令状态，并将南向设备（UE）收到的信息上报到应用服务器（APP Server）上。</li>
</ul>
</li>
<li><p><strong>Decode接口和Encode接口 </strong></p>
<p>Decode接口的入参binaryData为设备发过来的CoAP报文的Payload部分，设备的上行报文可以分为设备数据上报、设备对平台命令的应答两种情况，在这两种情况下解码输出的字段不同；Encode接口的入参是Json格式数据，是平台下发的消息或应答，平台的下行报文可以分为平台命令下发、平台对设备上报数据的相应两种情况。</p>
</li>
</ol>
<h3 id="南向设备对接"><a href="#南向设备对接" class="headerlink" title="南向设备对接"></a>南向设备对接</h3><ol>
<li><p>业务发放流程</p>
<ul>
<li>应用服务器用过申请的APP ID/密码登录Oceanconnect平台；</li>
<li>应用服务器进行设备开户，设置IoT设备的关键标识到平台侧，为IoT设备开户；</li>
<li>IoCM把IoT设备的信息存入MongoDB。</li>
</ul>
<blockquote>
<p>必须先为IoT设备在Oceanconnect平台中开户，否则设备是非法的，不能接入到平台中来。</p>
</blockquote>
</li>
<li><p>南向注册流程</p>
<ul>
<li>IoT设备上电、连网后，带着设备的关键词标识到Oceanconnect发起注册，Oceanconnect发现应用服务器已经为设备开户，注册成功；</li>
<li>IoT设备根据鉴权算法计算出鉴权码，用鉴权码去Oceanconnect平台鉴权；</li>
<li>IoCM在MongoDB更新IoT设备状态信息；</li>
<li>IoCM通知IoT应用服务器设备已经上线。</li>
</ul>
<blockquote>
<p><strong>注册只需要执行一次</strong>，注册成功后就不需要注册了；但为了数据安全，<strong>鉴权需要执行多次</strong>，一般IoT设备主动跟平台发消息是需要先鉴权。</p>
</blockquote>
</li>
<li><p>南向消息上报流程</p>
<ul>
<li>当IoT设备发现满足消息上报条件时，主动发消息给Oceanconnect平台；</li>
<li>根据收到的消息，IoCM判断是否需要存入数据库，如果需要存入数据库，则把消息保存到MongoDB中；</li>
<li>根据收到的消息，IoCM判断是否需要上报给应用服务器，如果需要，则把消息转发给应用服务器。</li>
</ul>
<blockquote>
<p>不同IoT设备消息上报机制不同，有的是周期性上报，每隔一段时间上报一次消息，有的是事件性上报，检测到某些事件时发消息通知平台。</p>
</blockquote>
</li>
<li><p>控制命令下发流程</p>
<ul>
<li>应用服务器主动向IoT设备下发控制命令，Oceanconnect平台把命令转发给IoT终端；</li>
<li>IoT设备收到命令后，执行控制命令的内容，并判断是否需要回复命令，如果需要，则回复命令；</li>
<li>根据收到的命令，IoCM判断是否需要上报给应用服务器，如果需要，则把命令转发给应用服务器。</li>
</ul>
<blockquote>
<p>为了省电，很多IoT设备不是一直在线的，比如水表、电表等，这类设备的控制命令往往不是实时转发的，Oceanconnect收到这类控制命令后，会把命令存储起来，等到IoT设备主动跟平台发命令时，再把控制命令转发下去。</p>
</blockquote>
</li>
</ol>
<h2 id="四、NB-IoT标准及解决方案"><a href="#四、NB-IoT标准及解决方案" class="headerlink" title="四、NB-IoT标准及解决方案"></a>四、NB-IoT标准及解决方案</h2><blockquote>
<p>NB-IoT（窄带蜂窝物联网）产业正在迅速崛起，这项技术在有效提供深度市内覆盖的同时，可以支持大量的低吞吐率、超低成本设备连接，并具有低功耗、优化的网络架构等独特优势。</p>
</blockquote>
<h3 id="NB-IoT物理层设计"><a href="#NB-IoT物理层设计" class="headerlink" title="NB-IoT物理层设计"></a>NB-IoT物理层设计</h3><ol>
<li>系统带宽：180kHz；</li>
<li>下行技术：正交频分多址（OFDMA），子载波间隔达15kHz，共12个子载波；</li>
<li>上行技术：单载波频分多址（SC-FDMA）。</li>
</ol>
<blockquote>
<ul>
<li>OFDMA（正交频分多址）：OFDMA是OFDM技术的演进，将OFDM和FDMA技术结合，再利用OFDM对信道进行子载波化后，在部分子载波上加载传输数据的传输技术。</li>
<li>OFDMA是一种多址接入调制技术，用户通过OFDMA共享频带资源，接入系统。</li>
<li>OFDMA又分为子信道OFDMA和调频OFDMA。</li>
</ul>
</blockquote>
<h3 id="NB-IoT物理信道与物理信号"><a href="#NB-IoT物理信道与物理信号" class="headerlink" title="NB-IoT物理信道与物理信号"></a>NB-IoT物理信道与物理信号</h3><p>为了减少实现的复杂性，NB-IoT精简了不必要的物理信道，在<strong>下行</strong>只有<strong>三种物理信道</strong>（窄带物理广播信道NPBCH、窄带物理下行控制信道NPDCCH、窄带物理下行共享信道NPDSCH）和<strong>两种参考信号</strong>（窄带参考信号NRS、窄带同步信号NSS），在<strong>上行</strong>只有<strong>两种物理信道</strong>（窄带物理上行共享信道NPUSCH、窄带物理随机接入信道NPRACH）和<strong>一种参考信号</strong>（窄带参考信号NDMRS）。总之，NB-IoT的物理信道通过降低目标速率、多次传输低阶调制方式等措施，以达到增加覆盖、降低成本、降低功耗的目的。</p>
<h3 id="NB-IoT部署方式"><a href="#NB-IoT部署方式" class="headerlink" title="NB-IoT部署方式"></a>NB-IoT部署方式</h3><p>NB-IoT构建于蜂窝网络，可采取带内、保护带或独立载波等三种部署方式，与现有网络共存，支持SingleRAN的平滑演进。其只消耗大约180kHz的频段，可直接部署于GSM网络、UMTS网络或LTE网络，以降低部署成本、实现平滑升级。</p>
<p>NB-IoT支持的三种部署方式：<strong>独立部署</strong>（Stand-alone）、<strong>保护带部署</strong>（Guard-band）、<strong>带内部署</strong>（Inband）。</p>
<ul>
<li>独立部署模式：利用单独的频带，适合用于GSM频段的重耕；</li>
<li>保护带部署模式：利用LTE系统中边缘无用频带；</li>
<li>带内模式：利用LTE载波重点的任何资源块。</li>
</ul>
<h3 id="NB-IoT关键特性"><a href="#NB-IoT关键特性" class="headerlink" title="NB-IoT关键特性"></a>NB-IoT关键特性</h3><ol>
<li><strong>超强覆盖</strong>：最大耦合损耗MCL比GPRS/LTE增加20dB；提升功率谱密度、重复发送；</li>
<li><strong>超低成本</strong>：180kHz窄带宽，基带复杂度低；低采样率；单天线，半双工，RF成本低；峰均比低，功效效率高；协议栈简化；</li>
<li><strong>超低功耗</strong>：PSM、eDRX；</li>
<li><strong>超大连接</strong>：上行业务调度单元小、减小空口信令开销、PSM/eDRX降低了每个设备的资源使用量、基站优化、核心网优化。</li>
</ol>
<h2 id="五、华为NB-IoT芯片与模组"><a href="#五、华为NB-IoT芯片与模组" class="headerlink" title="五、华为NB-IoT芯片与模组"></a>五、华为NB-IoT芯片与模组</h2><h3 id="华为Boudica芯片概述"><a href="#华为Boudica芯片概述" class="headerlink" title="华为Boudica芯片概述"></a>华为Boudica芯片概述</h3><p>华为Boudica芯片拥有三个CPU，分别为<strong>安全核</strong>（S核，负责启动A、C核，拥有擦除和写内置flash的权限）、<strong>协议核</strong>（C核，主要包含NB-IoT及LWIP协议）、<strong>应用核</strong>（A核，主要负责AT指令解析、外置flash读写以及其他上层应用、协议等），三核之间采用共享内存的方式实现核内通信。</p>
<p>华为Boudica芯片研发阶段可靠性试验总体可以分为四大类，包括环境适应性试验、可靠性极限测试、长期可靠性测试、小批量可靠性测试。</p>
<h2 id="六、CoAP协议技术原理"><a href="#六、CoAP协议技术原理" class="headerlink" title="六、CoAP协议技术原理"></a>六、CoAP协议技术原理</h2><h3 id="CoAP协议概述"><a href="#CoAP协议概述" class="headerlink" title="CoAP协议概述"></a>CoAP协议概述</h3><p>CoAP是受限制的应用协议（Constrained Application Protocol）的简称。在当前由PC机组成的世界，信息交换是通过TCP和应用层协议HTTP实现的，但对于小型设备而言，实现TCP和HTTP协议显然是一个过分的要求，为了让小设备可以接入互联网，CoAP协议被设计出来。CoAP协议是一种应用层协议，它运行于UDP协议之上而不是像HTTP那样运行于TCP之上。CoAP协议非常小巧，最小的数据包仅为4字节。</p>
<p>应用层协议有CoAP、MQTT（消息队列遥测传输协议）、XMPP（可扩展消息处理现场协议）、HTTP等，物联网主流使用的是CoAP协议和MQTT协议。</p>
<h3 id="CoAP协议特点"><a href="#CoAP协议特点" class="headerlink" title="CoAP协议特点"></a>CoAP协议特点</h3><ol>
<li>CoAP协议基于UDP；</li>
<li>采用异步消息交换；</li>
<li>CoAP协议是二进制格式的，HTTP是文本格式的，CoAP比HTTP更加紧凑；</li>
<li>轻量化，CoAP最小长度仅4个字节；</li>
<li>支持可靠传输，数据重传，块传输，确保数据可靠到达；</li>
<li>支持URI和Content-Type；</li>
<li>能实现简单的数据缓存和代理；无状态的HTTP映射，可以构建代理服务器，使构建代理服务器，使CoAP资源可以用HTTP访问，也可以使HTTP接口实现于CoAP协议之上；</li>
<li>支持DTLS；</li>
<li>CoAP基于REST，服务器的资源地址和互联网一样也有类似URI的格式，客户端同样有POST，GET，PUT，DELETE方法来访问server，但是想对HTTP简化实现降低复杂度（代码更小，封包更小）。</li>
</ol>
<h3 id="RESTful架构"><a href="#RESTful架构" class="headerlink" title="RESTful架构"></a>RESTful架构</h3><p>REST是一种设计风格而不是标准，如果一个架构符合REST原则，我们就称它为RESTful架构，REST就是表现层状态转化，其中表现层其实指的是资源的表现层，即资源在网络中某种形式进行状态转移。</p>
<h3 id="CoAP协议报文结构"><a href="#CoAP协议报文结构" class="headerlink" title="CoAP协议报文结构"></a>CoAP协议报文结构</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th style="text-align:center">位</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Ver</td>
<td style="text-align:center">2bits</td>
<td style="text-align:center">版本编号</td>
<td style="text-align:center">指示CoAP协议的版本号，类似于HTTP1.0和HTTP1.1，版本编号占2位。</td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center">2bits</td>
<td style="text-align:center">报文类型</td>
<td style="text-align:center">CoAP协议定义了4种不同形式的报文，包括CON，NON，ACK，RST。</td>
</tr>
<tr>
<td style="text-align:center">TKL</td>
<td style="text-align:center">4bits</td>
<td style="text-align:center">Token length</td>
<td style="text-align:center">Token长度。</td>
</tr>
<tr>
<td style="text-align:center">Code</td>
<td style="text-align:center">8bits</td>
<td style="text-align:center">表现形式</td>
<td style="text-align:center">Code在CoAP请求报文和相应报文中具有不同的表现形式。</td>
</tr>
<tr>
<td style="text-align:center">Message ID</td>
<td style="text-align:center">16bits</td>
<td style="text-align:center">报文编号</td>
<td style="text-align:center">用于重复消息检测、匹配消息类型等。每个CoAP报文都有一个ID，在一次会话中ID总是保持不变，但是在这个会话结束之后，该ID会被回收利用。</td>
</tr>
<tr>
<td style="text-align:center">Token</td>
<td style="text-align:center"></td>
<td style="text-align:center">标识具体内容</td>
<td style="text-align:center">ID的另一种表现，通过TKL制定Token长度。</td>
</tr>
<tr>
<td style="text-align:center">Options</td>
<td style="text-align:center"></td>
<td style="text-align:center">报文选项</td>
<td style="text-align:center">通过报文选项可设定CoAP主机，CoAP URI，CoAP请求参数和负载媒体类型等。</td>
</tr>
<tr>
<td style="text-align:center">1111 1111</td>
<td style="text-align:center">8bits</td>
<td style="text-align:center">分隔符</td>
<td style="text-align:center">CoAP报文和具体负载之间的分隔符，固定一个字节。</td>
</tr>
<tr>
<td style="text-align:center">Payload</td>
<td style="text-align:center"></td>
<td style="text-align:center">交互数据</td>
<td style="text-align:center">真正有用的被交互的数据。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="CoAP协议逻辑分层"><a href="#CoAP协议逻辑分层" class="headerlink" title="CoAP协议逻辑分层"></a>CoAP协议逻辑分层</h3><p>CoAP协议逻辑上分两层：<strong>资源请求/响应层</strong>（Request/Response）和<strong>消息层</strong>（Messages）。Messages层只负责控制端到端的报文交互；Request/Response层负责传输资源操作的请求和响应。</p>
<h3 id="CoAP-Messages模型"><a href="#CoAP-Messages模型" class="headerlink" title="CoAP Messages模型"></a>CoAP Messages模型</h3><ol>
<li>Reliability Mode（可靠消息传播）：主要通过确认及重传机制来实现的，客户端发送消息后，需要等待服务器收到通知，如果在规定时间内，没有收到需要重新发送数据。可靠传输是基于CON消息传输的，服务器端收到CON类型的消息后，需要返回ACK消息，客户端在指定时间ACK_TIMEOUT内收到ACK消息后，才代表这个消息已发送到服务器端。</li>
<li>Non-Reliability Mode（非可靠消息传播）：客户端只管发送消息，不管服务器端有没有收到，因此可能存在丢包。非可靠消息传播是基于NON消息传输的，服务器端收到NON类型消息后，不用回复ACK消息。</li>
</ol>
<h3 id="CoAP-Messages分类"><a href="#CoAP-Messages分类" class="headerlink" title="CoAP Messages分类"></a>CoAP Messages分类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字段类型</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CON消息</td>
<td style="text-align:center">需要确认的消息</td>
<td style="text-align:center">Receipt方必须对消息回复ACK消息或者Reset。</td>
</tr>
<tr>
<td style="text-align:center">NON消息</td>
<td style="text-align:center">不需要确认的消息</td>
<td style="text-align:center">Receipt方可能回复Reset。</td>
</tr>
<tr>
<td style="text-align:center">ACK消息</td>
<td style="text-align:center">用于向客户端确认CON消息已收到</td>
<td style="text-align:center">可以携带同步可靠响应模式Piggybacked Response。</td>
</tr>
<tr>
<td style="text-align:center">RST消息</td>
<td style="text-align:center">用于回复收到的无法处理的消息</td>
<td style="text-align:center">可通过一个Empty Message触发一个Reset，用于Endpoint的保活检测。</td>
</tr>
</tbody>
</table>
</div>
<p>协议定义的Message的种类，由报文中的2bits的【T】字段确认具体类型；</p>
<p>Empty Message是一个既不是Request也不是Response的Message。</p>
<h3 id="CoAP-Message的可靠传输"><a href="#CoAP-Message的可靠传输" class="headerlink" title="CoAP Message的可靠传输"></a>CoAP Message的可靠传输</h3><ol>
<li>CON和ACK/Reset Message中携带Message ID用于配对是一次可靠传输过程，支持重复检测。</li>
<li>简单的停等基于指数回退的重传机制保证可靠性：客户端构造CON消息发送到服务器端，未收到ACK或Reset Message时，支持基于指数回退的重传机制；服务器端如果可以处理该消息，返回ACK，否则返回Reset。</li>
<li>Message的可靠传输由一个CON消息发起。</li>
<li>CON消息总是承载一个Request或Response，除非是一个为了触发Reset Message的Empty Message。</li>
<li>Receipt收到一个CON消息，处理结果是回复一个ACK消息（携带匹配的Message ID）或者在某些情况（Receipt不能正确处理消息、Message是一个Empty Message、Message存在格式错误）下Rejecting一个消息。</li>
<li>Rejecting一个消息的结果是回复Reset Message或者忽略它。</li>
</ol>
<h3 id="CoAP-Message的非可靠传输"><a href="#CoAP-Message的非可靠传输" class="headerlink" title="CoAP Message的非可靠传输"></a>CoAP Message的非可靠传输</h3><p>NON消息中仍然携带Message ID用于重复检测：客户端对于不需要可靠传输的Message通过NON消息传递；虽然不需要ACK确认NON消息，服务器端仍然可能会返回Reset给客户端（比如服务器端不能处理这个NON消息）。</p>
<h3 id="CoAP-Request-Response模型"><a href="#CoAP-Request-Response模型" class="headerlink" title="CoAP Request/Response模型"></a>CoAP Request/Response模型</h3><p>CoAP Request和Response的语法通过Message承载（同样有可靠传输和非可靠传输），其中可靠传输Request和Response的响应方式有两种：<strong>同步可靠响应模式</strong>（Piggybacked Response）、<strong>异步可靠响应模式</strong>（Separate Response）。</p>
<ol>
<li><p>CoAP Request/Response可靠响应模式：同步可靠响应模式（Piggybacked Response）中Request和Response通过Token配对；异步可靠响应模式（Separate Response）中跨多对消息的Request和Response通过Token配对。</p>
</li>
<li><p>CoAP Request/Response非可靠响应模式：Request和Response通过Token配对；对于通过NON承载的Request和Response，服务器端可以选择通过CON返回Response。</p>
</li>
</ol>
<h2 id="七、MQTT协议技术原理"><a href="#七、MQTT协议技术原理" class="headerlink" title="七、MQTT协议技术原理"></a>七、MQTT协议技术原理</h2><h3 id="MQTT协议概述"><a href="#MQTT协议概述" class="headerlink" title="MQTT协议概述"></a>MQTT协议概述</h3><p>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输协议）构建于TCP/IP协议之上，是为硬件性能低下的远程设备以及网络状况糟糕的情况下二设计的发布/订阅型“轻量级”通讯协议。MQTT协议可以在严重受限的设备硬件和高延迟/带宽有限的网络上实现，其灵活性使得为IoT设备和服务的多样化应用场景提供支持成为可能。</p>
<h3 id="MQTT协议特点"><a href="#MQTT协议特点" class="headerlink" title="MQTT协议特点"></a>MQTT协议特点</h3><ol>
<li>使用发布（Publish）/订阅（Subscribe）消息模式，提供了一对多的消息发布和应用之间的解耦。</li>
<li>消息传输不需要知道负载内容。</li>
<li>提供三种等级的质量服务。</li>
<li>很小的传输消耗和协议数据交换，最大限度减少网络流量。</li>
<li>异常连接断开发生时，能通知到相关各方。</li>
</ol>
<h3 id="MQTT的发布-订阅模式"><a href="#MQTT的发布-订阅模式" class="headerlink" title="MQTT的发布/订阅模式"></a>MQTT的发布/订阅模式</h3><ol>
<li>客户端（包括发布者和订阅者）连接到代理服务器（是任何发布/订阅协议的核心），以订阅代理中的任何消息主题。</li>
<li>客户端通过将消息和主题发送给代理，发布某个主题范围内的消息。</li>
<li>代理然后通过将消息转发给所有订阅该主题的客户端。</li>
<li>发布/订阅解耦（空间解耦、时间解耦、同步解耦）了消息的发布者和接受者。</li>
</ol>
<h3 id="MQTT在主题通配符"><a href="#MQTT在主题通配符" class="headerlink" title="MQTT在主题通配符"></a>MQTT在主题通配符</h3><p>（1）、单级（只能用于单个主题层级匹配的通配符）：+</p>
<p>（2）、多级（用于匹配主题中任意层级的通配符，放在末尾且前面必须加反斜杠）：#</p>
<h3 id="MQTT服务质量（QoS）"><a href="#MQTT服务质量（QoS）" class="headerlink" title="MQTT服务质量（QoS）"></a>MQTT服务质量（QoS）</h3><p>服务质量（QoS）级别一种关于发送者和接受者之间信息投递的保证协议。MQTT中有三种QoS级别：QoS 0（最多分发一次；消息的分发依赖于底层网络的能力，接受者不会发送响应，发送者也不会重试，消息可能送达一次也看根本没送达）、QoS 1（至少分发一次；服务质量确保消息至少送达一次，QoS 1的发布报文的可变报头中包含一个报文标识符，需要PUBACK报文确认）、QoS 2（仅分发一次；最高等的服务质量，消息丢失和重复都是不可接受的，使用这个服务质量登记会有额外的开销）。</p>
<h3 id="MQTT控制报文结构"><a href="#MQTT控制报文结构" class="headerlink" title="MQTT控制报文结构"></a>MQTT控制报文结构</h3><p>MQTT控制报文结构：在MQTT协议中，一个MQTT数据包由：固定头（Fixed header，所有控制报文都包含）、可变头（Variable header，部分控制报文包含）、消息体（payload，部分控制报文包含）三部分构成。</p>
<h3 id="MQTT连接"><a href="#MQTT连接" class="headerlink" title="MQTT连接"></a>MQTT连接</h3><p>MQTT连接是在客户端和代理服务器之间，连接是通过客户端向代理服务器发送连接消息（CONNECT）发起的，代理服务器会响应一个CONNACK消息和状态码，一旦连接建立，只要客户端不发送断开连接的命令或失去联系，代理服务器将保持连接。</p>
<h3 id="MQTT保留消息"><a href="#MQTT保留消息" class="headerlink" title="MQTT保留消息"></a>MQTT保留消息</h3><p>保留消息是一条将保留标志（retained flag）置为true的普通MQTT消息。<strong>代理服务器会针对主题依照QoS级别保留最后一条保留消息</strong>。保留消息存在的意义是为了订阅者能够立即受到消息而无需等待发布者发布下一条消息。一个主题的保留消息是最新的可知的有效数据，它不必是最新的数据，但它一定是将保留标志置为true的最新消息。</p>
<h3 id="MQTT遗嘱LWT"><a href="#MQTT遗嘱LWT" class="headerlink" title="MQTT遗嘱LWT"></a>MQTT遗嘱LWT</h3><p>MQTT使用遗嘱LWT功能通知其他客户端某个客户端意外断开了连接，每个客户端都可以在连接代理服务器是指定其最新的遗嘱（一个具备主题，保留标志，QoS的普通MQTT消息）。代理服务器会在以下情况下分发遗嘱消息：代理服务器发现一个I/O错误或者网络错误、客户端没有按时发送心跳包、客户端没有在断开连接前发送DISCONNECT包、代理服务器因为协议错误而断开连接。</p>
<h3 id="MQTT心跳包"><a href="#MQTT心跳包" class="headerlink" title="MQTT心跳包"></a>MQTT心跳包</h3><p>为了应对半开连接问题，MQTT提供了心跳（keep alive）机制。</p>
<ol>
<li><p>MQTT客户端向代理服务器发起CONNECT请求时，通过KeepAlive参数设置保活周期。</p>
</li>
<li><p>客户端在无报文发送时，按KeepAlive周期定时发送2字节的PINGREQ心跳报文，代理服务器收到PINGREQ心跳报文后，回复2字节的PINGRESP报文。</p>
</li>
<li>代理服务器在1.5个心跳周期内，既没有收到客户端发布订阅报文，也没有收到PINGREQ心跳报文时，主动心跳超时断开客户端TCP连接并且发送遗嘱消息（前提是客户端已经指定了遗嘱）。</li>
<li>客户端可以在任何时间发送PINGREQ来确认网络连接是有效的，PINGREQ不包含任何消息体（payload）。</li>
</ol>
<h2 id="八、NB-IoT模组常用AT指令"><a href="#八、NB-IoT模组常用AT指令" class="headerlink" title="八、NB-IoT模组常用AT指令"></a>八、NB-IoT模组常用AT指令</h2><h3 id="NB-IoT芯片的常用AT指令"><a href="#NB-IoT芯片的常用AT指令" class="headerlink" title="NB-IoT芯片的常用AT指令"></a>NB-IoT芯片的常用AT指令</h3><p>NB-IoT芯片的AT指令可以分为测试指令（AT+<X>=?）、查询指令（AT+<X>?）、有参数的执行指令（AT+<X>=&lt;…&gt;）和无参数的执行指令（AT+<X>）。</p>
<h3 id="NB-IoT-3GPP相关指令"><a href="#NB-IoT-3GPP相关指令" class="headerlink" title="NB-IoT 3GPP相关指令"></a>NB-IoT 3GPP相关指令</h3><ol>
<li>AT+CGSN 查询模块序列号IMEI号；</li>
<li>AT+CEREG 查询网络注册状态；</li>
<li>AT+CSCON 查询终端与基站连接状态；</li>
<li>AT+CGPADDR 显示PDP地址；</li>
<li>AT+CMEE 报告终端错误；</li>
<li>AT+CFUN 设置模块射频功能；</li>
<li>AT+NRB 重启模块；</li>
<li>AT+CSQ 查询模块信号强度；</li>
<li>AT+CGATT 查询网络激活状态；</li>
</ol>
<h2 id="九、物联网操作系统概述"><a href="#九、物联网操作系统概述" class="headerlink" title="九、物联网操作系统概述"></a>九、物联网操作系统概述</h2><h3 id="RTOS概述"><a href="#RTOS概述" class="headerlink" title="RTOS概述"></a>RTOS概述</h3><p>RTOS（Real-time operating system，实时操作系统）是管理系统硬件和软件资源的系统软件，以方便开发者使用，操作系统管理的资源包括处理器、存储器、外设、文件系统等等。实时操作系统最大的特色就是“实时性”，即如果有任务需要执行，实时操作系统会在短时间内执行该任务，保证了任务在指定时间内完成。实时操作系统根据任务执行的实时性，可以分为“软实时”操作系统和“硬实时”操作系统，“硬实时”操作系统比“软实时”操作系统响应更快、实时性更高，“硬实时”操作系统大多应用于工业领域，“硬实时”操作系统必须使任务在确定的时间内完成，“软实时”操作系统能让绝大多数任务在确定的时间内完成。<strong>Huawei LiteOS是一款“软实时”操作系统。</strong></p>
<h3 id="RTOS的优势"><a href="#RTOS的优势" class="headerlink" title="RTOS的优势"></a>RTOS的优势</h3><ol>
<li>降低开发难度，直接使用系统API，即可完成系统资源的申请、多任务的配合（基于优先级的实时抢占调度，同优先级的时间片调度），以及任务间的通信等（如锁、事件等机制）。</li>
<li>增加代码可读性，易于维护和管理。</li>
<li>提升可移植性，对接不同芯片的工作由操作系统完成，应用开发者只需要关注OS层接口。</li>
</ol>
<h2 id="十、Huawei-LiteOS基础框架"><a href="#十、Huawei-LiteOS基础框架" class="headerlink" title="十、Huawei LiteOS基础框架"></a>十、Huawei LiteOS基础框架</h2><h3 id="Huawei-LiteOS-Kernel概述"><a href="#Huawei-LiteOS-Kernel概述" class="headerlink" title="Huawei LiteOS Kernel概述"></a>Huawei LiteOS Kernel概述</h3><p>Huawei LiteOS基础内核是最精简的Huawei LiteOS操作系统代码，包括任务管理、内存管理、时间管理、通信机制、中断管理、事件管理、定时器等操作系统基础组件，可以单独运行。</p>
<h3 id="Huawei-LiteOS-Kernel的优势"><a href="#Huawei-LiteOS-Kernel的优势" class="headerlink" title="Huawei LiteOS Kernel的优势"></a>Huawei LiteOS Kernel的优势</h3><ol>
<li>高实时性，高稳定性；</li>
<li>超小内核，基础内核体积可以裁剪至不到10KB；</li>
<li>低功耗；</li>
<li>支持功能静态裁剪。</li>
</ol>
<h3 id="Huawei-LiteOS低功耗设计"><a href="#Huawei-LiteOS低功耗设计" class="headerlink" title="Huawei LiteOS低功耗设计"></a>Huawei LiteOS低功耗设计</h3><ol>
<li><p>调度机制：集中式任务调度机制；</p>
</li>
<li><p>传输机制：轻量级网络协议栈、路由算法改进、Sleeping Router。</p>
</li>
</ol>
<h3 id="Huawei-LiteOS安全设计"><a href="#Huawei-LiteOS安全设计" class="headerlink" title="Huawei LiteOS安全设计"></a>Huawei LiteOS安全设计</h3><ol>
<li>内核层：SafeArea（使得进程之间相互隔离；保护密钥、证书等敏感数据，只能通过保护API访问）、区分用户态和内核态（限制应用对硬件和资源的访问）、安全加载（对可信应用核非可信应用采取不同的加载和资源分配机制）；</li>
<li>传输层：基于TLS/DTLS的加密传输；</li>
<li>应用层：可信应用签名、API认证。</li>
</ol>
<h3 id="Huawei-LiteOS-Kernel概述-1"><a href="#Huawei-LiteOS-Kernel概述-1" class="headerlink" title="Huawei LiteOS Kernel概述"></a>Huawei LiteOS Kernel概述</h3><p>Huawei LiteOS Kernel基本框架包括内存（动态内存和静态内存）、时间管理（系统时间、软件定时器和Tick）、IPC通信（消息队列和事件）、硬件相关（中断、异常和硬件定时器）、任务（任务调度）及任务同步（互斥锁和信号量）。</p>
<h3 id="Huawei-LiteOS-Kernel任务模块—任务概述"><a href="#Huawei-LiteOS-Kernel任务模块—任务概述" class="headerlink" title="Huawei LiteOS Kernel任务模块—任务概述"></a>Huawei LiteOS Kernel任务模块—任务概述</h3><ol>
<li>从系统的角度看，<strong>任务是竞争系统资源的最小运行单位</strong>，任务可以使用或等待CPU、使用内存空间等系统资源，并独立于其他任务运行。</li>
<li>Huawei LiteOS中的任务是<strong>抢占式调度</strong>机制，同时支持<strong>时间片轮转调度</strong>机制。</li>
<li>高优先级的任务可以打断低优先级任务，低优先级的任务必须在高优先级任务阻塞或结束后才能得到调度。</li>
<li>Huawei LiteOS的任务一共有<strong>32个优先级</strong>，最高优先级为0，最低优先级为31。</li>
</ol>
<h3 id="Huawei-LiteOS-Kernel任务模块—任务状态"><a href="#Huawei-LiteOS-Kernel任务模块—任务状态" class="headerlink" title="Huawei LiteOS Kernel任务模块—任务状态"></a>Huawei LiteOS Kernel任务模块—任务状态</h3><ol>
<li>就绪态（Ready）：该任务在就绪列表中，就绪的任务已经具备执行的能力，只需等待调度器进行调度，新创建的任务会初始化为就绪态；</li>
<li>运行态（Running）：该状态表明任务正在执行，此时它占用处理器，LiteOS调度器选择运行的永远是处于最高优先级的就绪态任务，当任务被运行的一刻，它的任务状态就变成了运行态；</li>
<li>阻塞态（Blocked）：如果当任务当前正在等待某个时序或外部中断，则该任务处于阻塞状态，该任务不在就绪列表中。包含任务被挂起、任务被延时、任务正在等待信号量、读写队列或者等待读写事件等。</li>
<li>退出态（Dead）：该任务运行结束，等待系统回收资源。</li>
<li>就绪态→运行态：任务创建后进入就绪态，发生任务切换时，就绪列表中最高优先级的任务被执行，从而进入运行态，但此刻该任务依旧在就绪列表中。</li>
<li>运行态→阻塞态：正在运行的任务发生阻塞（挂起、延时、读信号量等待）时，该任务就会从就绪列表中删除，任务状态由运行态变成阻塞态，然后发生任务切换，运行就绪列表中剩余最高优先级任务。</li>
<li>阻塞态→就绪态（阻塞态→运行态）：阻塞态的任务被恢复后（任务恢复、延时时间超时、读信号量超时或读到信号量等），此时被恢复的任务会被加入就绪列表，从而由阻塞态变成就绪态；此时如果被恢复任务的优先级高于正在运行任务的优先级，则会发生任务切换，讲该任务由就绪态变成运行态。</li>
<li>就绪态→阻塞态：任务也有可能在就绪态时被阻塞（挂起），此时任务状态会由就绪态转变为阻塞态，该任务从就绪列表中删除，不会参与任务调度，直到该任务被恢复。</li>
<li>运行态→就绪态：有更高优先级任务创建或者恢复后，会发生任务调度，此刻就绪列表中最高优先级任务会变为运行态，那么原先运行的任务由运行态变为就绪态，依然在就绪列表中。</li>
<li>运行态→退出态：运行中的任务运行结束，任务状态由运行态转变为退出态，退出态包含任务运行结束的正常退出以及impossible状态。</li>
<li>阻塞态→退出态：阻塞的任务调用删除接口，任务状态由阻塞态转变为退出态。</li>
</ol>
<h3 id="Huawei-LiteOS-Kernel内存模块—内存概述"><a href="#Huawei-LiteOS-Kernel内存模块—内存概述" class="headerlink" title="Huawei LiteOS Kernel内存模块—内存概述"></a>Huawei LiteOS Kernel内存模块—内存概述</h3><ol>
<li><p>内存管理模块系统的内存资源，是操作系统的核心模块之一。主要包括内存的初始化、分配以及释放。</p>
</li>
<li><p>在系统运行过程中，内存管理模块通过对内存的申请/释放操作，来管理用户和OS对内存的使用，使内存的利用率和使用效率达到最优，同时最大限度地解决系统的内存碎片问题。</p>
</li>
<li><p>Huawei LiteOS的内存管理分为静态内存和动态内存管理，提供内存初始化、分配、释放等功能。</p>
</li>
<li><p>动态内存：在动态内存池中分配用户指定大小的内存块。</p>
<p>优点：按需分配；</p>
<p>缺点：内存池中可能出现碎片。</p>
</li>
<li><p>静态内存：在静态内存池中分配用户初始化时预设（固定）大小的内存块。</p>
<p>优点：分配和释放效率高，静态内存池中无碎片；</p>
<p>缺点：只能申请到初始化预设大小的内存块，不能按需申请。</p>
</li>
</ol>
<h3 id="Huawei-LiteOS-Kernel硬件相关模块—中断概述"><a href="#Huawei-LiteOS-Kernel硬件相关模块—中断概述" class="headerlink" title="Huawei LiteOS Kernel硬件相关模块—中断概述"></a>Huawei LiteOS Kernel硬件相关模块—中断概述</h3><ol>
<li>中断是指出现需要时，CPU暂停执行当前程序，转而执行新程序的过程。即在程序运行过程中，系统出现了一个必须由CPU立即处理的事务，此时，CPU暂时中止当前程序的执行转而处理这个事务，这个过程就叫做中断。</li>
<li>通过中断机制，在外设不需要CPU介入时，CPU可以执行其他任务，而当外设需要CPU时通过产生中断信号使CPU立即中断当前任务来响应中断请求。这样可以使CPU避免把大量时间耗费在等待，查询外设状态的操作上，因此将大大提高系统实时性以及执行效率。</li>
<li>Huawei LiteOS的中断支持：中断初始化、中断创建、开/关中断、恢复中断、中断使能、中断屏蔽。</li>
<li>Huawei LiteOS的中断机制支持中断共享。</li>
</ol>
<h3 id="Huawei-LiteOS-Kernel硬件相关模块—中断运作机制"><a href="#Huawei-LiteOS-Kernel硬件相关模块—中断运作机制" class="headerlink" title="Huawei LiteOS Kernel硬件相关模块—中断运作机制"></a>Huawei LiteOS Kernel硬件相关模块—中断运作机制</h3><ol>
<li>保存当前处理机状态信息；</li>
<li>载入异常或中断处理函数到PC寄存器；</li>
<li>把控制权转交给处理函数并开始执行；</li>
<li>当处理函数执行完成时，恢复处理器状态信息；</li>
<li>从异常或中断中返回到前一个程序执行点。</li>
</ol>
<h3 id="Huawei-LiteOS-Kernel-IPC通信模块—队列概述"><a href="#Huawei-LiteOS-Kernel-IPC通信模块—队列概述" class="headerlink" title="Huawei LiteOS Kernel IPC通信模块—队列概述"></a>Huawei LiteOS Kernel IPC通信模块—队列概述</h3><p>队列又称消息队列，是一种常用于任务间通信的数据结构，实现了接收来自任务或中断的不固定长度的消息，并根据不同的接口选择传递消息是否存放在最近空间。任务能够从队列里面读取消息，当队列中的消息是空时，挂起读取任务；当队列中有新消息时，挂起的读取任务被唤醒并处理新消息。</p>
<h3 id="Huawei-LiteOS-Kernel-IPC通信模块—队列运作原理"><a href="#Huawei-LiteOS-Kernel-IPC通信模块—队列运作原理" class="headerlink" title="Huawei LiteOS Kernel IPC通信模块—队列运作原理"></a>Huawei LiteOS Kernel IPC通信模块—队列运作原理</h3><ol>
<li>创建队列时，根据用户传入队列长度和消息节点大小来开辟相应的内存空间以供该队列使用，返回队列ID。</li>
<li>在队列控制块中维护一个消息头节点位置Head和一个消息尾节点位置Tail来表示当前队列中消息存储情况。Head表示队列中被占用消息的起始位置；Tail表示队列中被空闲消息的起始位置；刚创建时Head和Tail均指向队列起始位置。</li>
<li>写队列时，根据Tail找到被占用消息节点末尾的空闲节点作为数据写入对象。如果Tail已经指向队列尾则采用回卷方式。根据usWritableCnt判断队列是否可以写入，不能对已满（usWritableCnt为0）队列进行写队列操作。</li>
<li>读队列时，根据Head找到最先写入队列中的消息节点进行读取。如果Head已经指向队列尾则采用回卷方式。根据usReadableCnt判断队列是否有消息读取，对全部空闲（usReadableCnt为0）队列进行读队列操作会引任务挂起。</li>
<li>删除队列时，根据传入的队列ID寻找到对应的队列，把队列状态置为未使用，释放原队列所占的空间，对应的队列控制头置为初始状态。</li>
</ol>
<h3 id="Huawei-LiteOS-Kernel任务同步模块—互斥锁概述"><a href="#Huawei-LiteOS-Kernel任务同步模块—互斥锁概述" class="headerlink" title="Huawei LiteOS Kernel任务同步模块—互斥锁概述"></a>Huawei LiteOS Kernel任务同步模块—互斥锁概述</h3><ol>
<li>互斥锁又称互斥型信号量，是一种特殊的二值性信号量，用于实现对共享资源的独占式处理。</li>
<li>任意时刻互斥锁的状态只有两种，开锁或闭锁。当有任务持有时，互斥锁处于闭锁状态，这个任务获得该互斥锁的所有权。当该任务释放它时，该互斥锁被开锁，任务失去该互斥锁的所有权。当一个任务持有互斥锁时，其他任务将不能再对该互斥锁进行开锁或持有。</li>
<li>多任务环境下往往存在多个任务竞争同一共享资源的应用场景，互斥锁可被用于对共享资源的保护从而实现独占式访问。另外，互斥锁可以解决信号量存在的优先级翻转问题。</li>
</ol>
<h3 id="Huawei-LiteOS-Kernel任务同步模块—信号量概述"><a href="#Huawei-LiteOS-Kernel任务同步模块—信号量概述" class="headerlink" title="Huawei LiteOS Kernel任务同步模块—信号量概述"></a>Huawei LiteOS Kernel任务同步模块—信号量概述</h3><ol>
<li>信号量（Semaphore）是一种实现任务间通信的机制，实现任务之间同步或临界资源的互斥访问，常用于协助一组相互竞争的任务来访问临界资源。</li>
<li>在多任务系统中，信号量功能可用于任务之间需要同步或互斥实现临界资源的保护。</li>
</ol>
<h3 id="Huawei-LiteOS-Kernel任务同步模块—信号量运作原理"><a href="#Huawei-LiteOS-Kernel任务同步模块—信号量运作原理" class="headerlink" title="Huawei LiteOS Kernel任务同步模块—信号量运作原理"></a>Huawei LiteOS Kernel任务同步模块—信号量运作原理</h3><ol>
<li>信号量初始化，为配置的N个信号量申请内存（N值可以由用户自行配置，受内存限制）并把所有的信号量初始化成未使用，并加入到未使用链表中供系统使用。</li>
<li>信号量创建，从未使用的信号量链表中获取一个信号量资源，并设定初值。</li>
<li>信号量申请，若其计数器值大于0，则直接减1返回成功。否则任务阻塞,等待其它任务释放该信号量，等待的超时时间可设定。当任务被一个信号量阻塞时，将该任务挂到信号量等待任务队列的队尾。</li>
<li>信号量释放，若没有任务等待该信号量,则直接将计数器加1返回。否则唤醒该信号量等待任务队列上的第一个任务。</li>
<li>信号量删除，将正在使用的信号量置为未使用信号量，并挂回到未使用链表。</li>
<li>信号量允许多个任务在同一时刻访问同一资源，但会限制同一时刻访问此资源的最大任务数目。访问同一资源的任务数达到该资源的最大数量时，会阻塞其他试图获取该资源的任务，直到有任务释放该信号量。</li>
</ol>
<h3 id="Huawei-LiteOS-Kernel时间管理模块—时间管理概述"><a href="#Huawei-LiteOS-Kernel时间管理模块—时间管理概述" class="headerlink" title="Huawei LiteOS Kernel时间管理模块—时间管理概述"></a>Huawei LiteOS Kernel时间管理模块—时间管理概述</h3><ol>
<li>时间管理以系统时钟为基础。时间管理提供给应用程序所有和时间有关的服务。</li>
<li>系统时钟是由定时/计时器产生的输出脉冲触发中断而产生的，一般定义为整数或长整数。输出脉冲的周期叫做一个“时钟滴答”。系统时钟也成为时标或者Tick，一个Tick的时长可以静态配置。</li>
<li>芯片CPU的计时是以Tick为单位的，Tick与秒之间的对应关系可以配置。</li>
</ol>
<h3 id="Huawei-LiteOS-Kernel模块—双向链表"><a href="#Huawei-LiteOS-Kernel模块—双向链表" class="headerlink" title="Huawei LiteOS Kernel模块—双向链表"></a>Huawei LiteOS Kernel模块—双向链表</h3><ol>
<li>双向链表是指含有<strong>往前和往后两个方向的链表</strong>，即每个节点中除存放下一个节点指针外，还增加一个指向其一个节点的指针，其头指针head是唯一确认的。</li>
<li>从双向链表中的任意一个节点开始，都可以很方便地访问它的前驱节点和后继节点，这种数据结构形式使得双向链表在查找时更加方便，特别是大量数据的遍历。由于双向链表具有对称性，能方便地完成各种插入、删除等操作，但需要注意前后方向的操作。</li>
</ol>
<h3 id="Huawei-LiteOS框架"><a href="#Huawei-LiteOS框架" class="headerlink" title="Huawei LiteOS框架"></a>Huawei LiteOS框架</h3><ol>
<li>互联框架：解决不同协议终端的互联互通，支持自组网；</li>
<li>传感框架：提供统一的传感器管理、传感算法库和驱动管理；</li>
<li>安全框架：提供API认证、双向设备认证和加密算法库，提高终端的安全性。</li>
</ol>
<h2 id="十一、华为HiLink平台"><a href="#十一、华为HiLink平台" class="headerlink" title="十一、华为HiLink平台"></a>十一、华为HiLink平台</h2><h3 id="华为HiLink-Wi-Fi模组优势"><a href="#华为HiLink-Wi-Fi模组优势" class="headerlink" title="华为HiLink Wi-Fi模组优势"></a>华为HiLink Wi-Fi模组优势</h3><ol>
<li>高性能可靠</li>
<li>轻量级内核</li>
<li>集成高效方便</li>
<li>强大技术支持</li>
<li>生态互联互通</li>
</ol>
]]></content>
      <categories>
        <category>自学</category>
      </categories>
      <tags>
        <tag>IoT</tag>
        <tag>华为</tag>
        <tag>物联网</tag>
      </tags>
  </entry>
</search>
